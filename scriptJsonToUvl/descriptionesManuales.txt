key specifies the audit annotation key. The audit annotation keys of a ValidatingAdmissionPolicy must be unique. The key must be a qualified name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
valueExpression represents the expression which is evaluated by CEL to produce an audit annotation value. The expression must evaluate to either a string or null value. If the expression evaluates to a string, the audit annotation is included with the string value. If the expression evaluates to null or empty string the audit annotation will be omitted. The valueExpression may be no longer than 5kb in length. If the result of the valueExpression is more than 10kb in length, it will be truncated to 10kb.

Name is an identifier for this match condition, used for strategic merging of MatchConditions, as well as providing an identifier for logging purposes. A good name should be descriptive of the associated expression. Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or * for all of those operations and any future admission operations that are added. If '*' is present, the length of the slice must be one. Required.
scope specifies the scope of this rule. Valid values are "Cluster", "Namespaced", and "*" "Cluster" means that only cluster-scoped resources will match this rule. Namespace API objects are cluster-scoped. "Namespaced" means that only namespaced resources will match this rule. "*" means that there are no scope restrictions. Subresources match the scope of their parent resource. Default is "*".

matchPolicy defines how the "MatchResources" list is used to match incoming requests. Allowed values are "Exact" or "Equivalent".
- Exact: match a request only if it exactly matches a specified rule. For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.

- Equivalent: match a request if modifies a resource listed in rules, even via another API group or version. For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.

Defaults to "Equivalent"

matchExpressions is a list of label selector requirements. The requirements are ANDed.
operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist. -- Pendiente

ClientConfig defines how to communicate with the hook. Required
`caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate. If unspecified, system trust roots on the apiserver are used.
`service` is a reference to the service for this webhook. Either `service` or `url` must be specified.
If specified, the port on the service that hosting webhook. Default to 443 for backward compatibility. `port` should be a valid port number (1-65535, inclusive).
FailurePolicy defines how unrecognized errors from the admission endpoint are handled - allowed values are Ignore or Fail. Defaults to Fail.
reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation. Allowed values are "Never" and "IfNeeded".

Never: the webhook will not be called more than once in a single admission evaluation.

IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation if the object being admitted is modified by other admission plugins after the initial webhook call. Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted. Note: * the number of additional invocations is not guaranteed to be exactly one. * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again. * webhooks that use this option may be reordered to minimize the number of additional invocations. * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
Defaults to "Never".
SideEffects states whether this webhook has side effects. Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown). Webhooks with side effects MUST implement a reconciliation system, since a request may be rejected by a future step in the admission chain and the side effects therefore need to be undone. Requests with the dryRun attribute will be auto-rejected if they match a webhook with sideEffects == Unknown or Some.

TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the webhook call will be ignored or the API call will fail based on the failure policy. The timeout value must be between 1 and 30 seconds. Default to 10 seconds. --
FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: "FieldsV1"
Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.
One of `name` or `selector` must be set, but `name` and `selector` are mutually exclusive properties. If one is set, the other must be unset.
name is the name of the resource being referenced.

One of `name` or `selector` must be set, but `name` and `selector` are mutually exclusive properties. If one is set, the other must be unset.
--
A single parameter used for all admission requests can be configured by setting the `name` field, leaving `selector` blank, and setting namespace if `paramKind` is namespace-scoped.
namespace is the namespace of the referenced resource. Allows limiting the search for params to a specific namespace. Applies to both `name` and `selector` fields.
A per-namespace parameter may be used by specifying a namespace-scoped `paramKind` in the policy and leaving this field empty.

- If `paramKind` is cluster-scoped, this field MUST be unset. Setting this field results in a configuration error.

- If `paramKind` is namespace-scoped, the namespace of the object being evaluated for admission will be used when this field is left unset. Take care that if this is left empty the binding must not match any cluster-scoped resources, which will result in an error.
`parameterNotFoundAction` controls the behavior of the binding when the resource exists, and name or selector is valid, but there are no parameters matched by the binding. If the value is set to `Allow`, then no matched parameters will be treated as successful validation by the binding. If set to `Deny`, then no matched parameters will be subject to the `failurePolicy` of the policy.

Allowed values are `Allow` or `Deny`

One of `name` or `selector` must be set, but `name` and `selector` are mutually exclusive properties. If one is set, the other must be unset.


Required
    
    "io_k8s_api_admissionregistration_v1_ValidatingAdmissionPolicy_status_conditions_status": "status of the condition, one of True, False, Unknown.",
    "io_k8s_api_admissionregistration_v1_ValidatingAdmissionPolicy_status_conditions_type": "type of condition in CamelCase or in foo.example.com/CamelCase.",

    "io_k8s_api_apps_v1_DaemonSet_spec_template_spec_volumes_awsElasticBlockStore_fsType": "fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore",
    
    "io_k8s_api_autoscaling_v2_HorizontalPodAutoscaler_spec_metrics_type": "type is the type of metric source.  It should be one of \"ContainerResource\", \"External\", \"Object\", \"Pods\" or \"Resource\", each mapping to a matching field in the object. Note: \"ContainerResource\" type is available on when the feature-gate HPAContainerMetrics is enabled",

    "io_k8s_api_autoscaling_v1_HorizontalPodAutoscaler_spec_minReplicas": "minReplicas is the lower limit for the number of replicas to which the autoscaler can scale down.  It defaults to 1 pod.  minReplicas is allowed to be 0 if the alpha feature gate HPAScaleToZero is enabled and at least one Object or External metric is configured.  Scaling is active as long as at least one metric value is available.",

--
        {
            "feature_name": "io_k8s_api_autoscaling_v2_HPAScalingRules_stabilizationWindowSeconds",
            "description": "stabilizationWindowSeconds is the number of seconds for which past recommendations should be considered while scaling up or scaling down. StabilizationWindowSeconds must be greater than or equal to zero and less than or equal to 3600 (one hour). If not set, use the default values: - For scale up: 0 (i.e. no stabilization is done). - For scale down: 300 (i.e. the stabilization window is 300 seconds long).",
            "type_data": "integer"
        },


--x

### Descripcion con error de escritura: Aparte se extrae solo un valor pero pueden haber varios... complejo

        "minDomains": {
          "description": "MinDomains indicates a minimum number of eligible domains. When the number of eligible domains with matching topology keys is less than minDomains, Pod Topology Spread treats \"global minimum\" as 0, and then the calculation of Skew is performed. And when the number of eligible domains with matching topology keys equals or greater than minDomains, this value has no effect on scheduling. As a result, when the number of eligible domains is less than minDomains, scheduler won't schedule more than maxSkew Pods to those domains. If value is nil, the constraint behaves as if MinDomains is equal to 1. Valid values are integers greater than 0. When value is not nil, WhenUnsatisfiable must be DoNotSchedule.\n\nFor example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same labelSelector spread as 2/2/2: | zone1 | zone2 | zone3 | |  P P  |  P P  |  P P  | The number of domains is less than 5(MinDomains), so \"global minimum\" is treated as 0. In this situation, new pod with the same labelSelector cannot be scheduled, because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones, it will violate MaxSkew.",
          "format": "int32",
          "type": "integer"
        },

        "topologyKey": {
          "description": "TopologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. We consider each <key, value> as a \"bucket\", and try to put balanced number of pods into each bucket. We define a domain as a particular instance of a topology. Also, we define an eligible domain as a domain whose nodes meet the requirements of nodeAffinityPolicy and nodeTaintsPolicy. e.g. If TopologyKey is \"kubernetes.io/hostname\", each Node is a domain of that topology. And, if TopologyKey is \"topology.kubernetes.io/zone\", each zone is a domain of that topology. It's a required field.",
          "type": "string"
        },
--x
Otra descripcion de la que se obtiene un unico valor// dejar por defecto
-
        {
            "feature_name": "io_k8s_api_core_v1_Service_spec_clusterIP",
            "description": "clusterIP is the IP address of the service and is usually assigned randomly. If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be blank) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are \"None\", empty string (\"\"), or a valid IP address. Setting this to \"None\" makes a \"headless service\" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies",
            "type_data": "string"
        },
        {
            "feature_name": "io_k8s_api_core_v1_Service_spec_clusterIPs",
            "description": "ClusterIPs is a list of IP addresses assigned to this service, and are usually assigned randomly.  If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be empty) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are \"None\", empty string (\"\"), or a valid IP address.  Setting this to \"None\" makes a \"headless service\" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName.  If this field is not specified, it will be initialized from the clusterIP field.  If this field is specified, clients must ensure that clusterIPs[0] and clusterIP have the same value.\n\nThis field may hold a maximum of two entries (dual-stack IPs, in either order). These IPs must correspond to the values of the ipFamilies field. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies",
            "type_data": "Boolean"
        },

        "handler": {
          "description": "handler specifies the underlying runtime and configuration that the CRI implementation will use to handle pods of this class. The possible values are specific to the node & CRI configuration.  It is assumed that all handlers are available on every node, and handlers of the same name are equivalent on every node. For example, a handler called \"runc\" might specify that the runc OCI runtime (using native Linux containers) will be used to run the containers in a pod. The Handler must be lowercase, conform to the DNS Label (RFC 1123) requirements, and is immutable.",
          "type": "string"
        },
--x
---
        "allocatedResourceStatuses": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "allocatedResourceStatuses stores status of resource being resized for the given PVC. Key names follow standard Kubernetes label syntax. Valid values are either:\n\t* Un-prefixed keys:\n\t\t- storage - the capacity of the volume.\n\t* Custom resources must use implementation-defined prefixed names such as \"example.com/my-custom-resource\"\nApart from above values - keys that are unprefixed or have kubernetes.io prefix are considered reserved and hence may not be used.\n\nClaimResourceStatus can be in any of following states:\n\t- ControllerResizeInProgress:\n\t\tState set when resize controller starts resizing the volume in control-plane.\n\t- ControllerResizeFailed:\n\t\tState set when resize has failed in resize controller with a terminal error.\n\t- NodeResizePending:\n\t\tState set when resize controller has finished resizing the volume but further resizing of\n\t\tvolume is needed on the node.\n\t- NodeResizeInProgress:\n\t\tState set when kubelet starts resizing the volume.\n\t- NodeResizeFailed:\n\t\tState set when resizing has failed in kubelet with a terminal error. Transient errors don't set\n\t\tNodeResizeFailed.\nFor example: if expanding a PVC for more capacity - this field can be one of the following states:\n\t- pvc.status.allocatedResourceStatus['storage'] = \"ControllerResizeInProgress\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"ControllerResizeFailed\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizePending\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizeInProgress\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizeFailed\"\nWhen this field is not set, it means that no resize operation is in progress for the given PVC.\n\nA controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus should ignore the update for the purpose it was designed. For example - a controller that only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid resources associated with PVC.\n\nThis is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.",
          "type": "object",
          "x-kubernetes-map-type": "granular"
        },
--
        {
            "feature_name": "io_k8s_api_batch_v1_CronJob_spec_jobTemplate_spec_podFailurePolicy_rules_onExitCodes_operator",
            "description": "Represents the relationship between the container exit code(s) and the specified values. Containers completed with success (exit code 0) are excluded from the requirement check. Possible values are:\n\n- In: the requirement is satisfied if at least one container exit code\n  (might be multiple if there are multiple containers not restricted\n  by the 'containerName' field) is in the set of specified values.\n- NotIn: the requirement is satisfied if at least one container exit code\n  (might be multiple if there are multiple containers not restricted\n  by the 'containerName' field) is not in the set of specified values.\nAdditional values are considered to be added in the future. Clients should react to an unknown operator by assuming the requirement is not satisfied.",
            "type_data": "string"
        },
        -Possible values are:\n\n- In: the requirement is satisfied if at least one container exit code\n  (might be multiple if there are multiple containers not restricted\n  by the 'containerName' field) is in the set of specified values.
        \n- NotIn: the requirement is satisfied if at least one container exit code\n  (might be multiple if there are multiple containers not restricted\n  by the 'containerName' field) is not in the set of specified values.
        \nAdditional values are considered to be added in the future. 
        {
            "feature_name": "io_k8s_api_batch_v1_CronJob_spec_jobTemplate_spec_podFailurePolicy_rules_onExitCodes_operator",
            "description": "Represents the relationship between the container exit code(s) and the specified values. Containers completed with success (exit code 0) are excluded from the requirement check. Possible values are:\n\n- In: the requirement is satisfied if at least one container exit code\n  (might be multiple if there are multiple containers not restricted\n  by the 'containerName' field) is in the set of specified values.\n- NotIn: the requirement is satisfied if at least one container exit code\n  (might be multiple if there are multiple containers not restricted\n  by the 'containerName' field) is not in the set of specified values.\nAdditional values are considered to be added in the future. Clients should react to an unknown operator by assuming the requirement is not satisfied.",
            "type_data": "string"
        },
--

        {
            "feature_name": "io_k8s_api_storage_v1alpha1_VolumeAttributesClass_parameters",
            "description": "parameters hold volume attributes defined by the CSI driver. These values are opaque to the Kubernetes and are passed directly to the CSI driver. The underlying storage provider supports changing these attributes on an existing volume, however the parameters field itself is immutable. To invoke a volume update, a new VolumeAttributesClass should be created with new parameters, and the PersistentVolumeClaim should be updated to reference the new VolumeAttributesClass.\n\nThis field is required and must contain at least one key/value pair. The keys cannot be empty, and the maximum number of parameters is 512, with a cumulative max size of 256K. If the CSI driver rejects invalid parameters, the target PersistentVolumeClaim will be set to an \"Infeasible\" state in the modifyVolumeStatus field.",
            "type_data": "Boolean"
        },
        \"Infeasible\" /// tamaño maximo de 512 o 256kb en total


--
      "description": "DeploymentStrategy describes how to replace existing pods with new ones.",
      "properties": {
        "rollingUpdate": {
          "$ref": "#/definitions/io.k8s.api.apps.v1.RollingUpdateDeployment",
          "description": "Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate."
        },
        "type": {
          "description": "Type of deployment. Can be \"Recreate\" or \"RollingUpdate\". Default is RollingUpdate.",
          "type": "string"
        }
      },
      "type": "object"

      "Can be"
-
        "JSONSchemaProps"
        "x-kubernetes-list-type": {
          "description": "x-kubernetes-list-type annotates an array to further describe its topology. This extension must only be used on lists and may have 3 possible values:\n\n1) `atomic`: the list is treated as a single entity, like a scalar.\n     Atomic lists will be entirely replaced when updated. This extension\n     may be used on any type of list (struct, scalar, ...).\n2) `set`:\n     Sets are lists that must not have multiple items with the same value. Each\n     value must be a scalar, an object with x-kubernetes-map-type `atomic` or an\n     array with x-kubernetes-list-type `atomic`.\n3) `map`:\n     These lists are like maps in that their elements have a non-index key\n     used to identify them. Order is preserved upon merge. The map tag\n     must only be used on a list with elements of type object.\nDefaults to atomic for arrays.",
          "type": "string"
        },
-
                "listKind": {
          "description": "listKind is the serialized kind of the list for this resource. Defaults to \"`kind`List\".",
          "type": "string"
        },

                },
        "readOnly": {
          "description": "Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.",
          "type": "boolean"
        },
        "recursiveReadOnly": {
          "description": "RecursiveReadOnly specifies whether read-only mounts should be handled recursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made recursively read-only.  If this field is set to IfPossible, the mount is made recursively read-only, if it is supported by the container runtime.  If this field is set to Enabled, the mount is made recursively read-only if it is supported by the container runtime, otherwise the pod will not be started and an error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to None (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.",
          "type": "string"
        },
        "subPath": {
          "description": "Path within the volume from which the container's volume should be mounted. Defaults to \"\" (volume's root).",
          "type": "string"
        },
        "subPathExpr": { -- Haciendo
          "description": "Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to \"\" (volume's root). SubPathExpr and SubPath are mutually exclusive.",
          "type": "string"
        }

        ### Valores de las propiedades que solo tienen 1 valor pero no se dicta si hay 2. Boolean se da por hecho que es true o false ###
                "suspend": {
          "description": "This flag tells the controller to suspend subsequent executions, it does not apply to already started executions.  Defaults to false.",
          "type": "boolean"
        },

        ### Lo mismo que antes pero con Integer... ####
    "io.k8s.api.batch.v1.CronJobSpec": {
    }

                "failedJobsHistoryLimit": { -- 
          "description": "The number of failed finished jobs to retain. Value must be non-negative integer. Defaults to 1.",
          "format": "int32",
          "type": "integer"
        },

                "startingDeadlineSeconds": { xx
          "description": "Optional deadline in seconds for starting the job if it misses scheduled time for any reason.  Missed jobs executions will be counted as failed ones.",
          "format": "int64",
          "type": "integer"
        },

        se repite mucho y tambien la muletilla "Defaults to":

                "readOnly": { xx-
          "description": "readOnly value to pass to ControllerPublishVolumeRequest. Defaults to false (read/write).",
          "type": "boolean"
        },


*** Duda sobre como agregar los valores que se obtienen de las descripciones si tienen una referencia
este ya tendria propiedades optional y las obtenidas de las descripciones serían alternative u optionals?
- Para seguir la sintaxis como optional
- Los interpreto como valores que puede tomar el feature pero...
- Quizas error de interpretacion mio porque no es del feature en general
Creo que solo ocurre en uno, es raro generar los valores y que tenga una referencia...
        
        "template": {--
          "$ref": "#/definitions/io.k8s.api.core.v1.PodTemplateSpec",
          "description": "Describes the pod that will be created when executing a job. The only allowed template.spec.restartPolicy values are \"Never\" or \"OnFailure\". More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/"
        },


        "fsType": {
        "description": "fsType is filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.",
        "type": "string"
        },


          "periodSeconds": { -- Minimums...
          "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
          "format": "int32",
          "type": "integer"
        }   ## quizas se pueda añadir una restriccion que comprenda entre 1 < X. default to 10, minimum 1



    "io.k8s.api.core.v1.DownwardAPIVolumeSource": { x-
      "description": "DownwardAPIVolumeSource represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.",
      "properties": {
        "defaultMode": {
          "description": "Optional: mode bits to use on created files by default. Must be a Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.",
          "format": "int32",
          "type": "integer"
        },


                },
        "port": {--
          "description": "port is an optional service port at which the webhook will be contacted. `port` should be a valid port number (1-65535, inclusive). Defaults to 443 for backward compatibility.",
          "format": "int32",
          "type": "integer"
        } ##port default, restriccion...


                "successThreshold": {-
          "description": "Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.",
          "format": "int32",
          "type": "integer"
        ### Para probar si hay valores por defecto
                  "failureThreshold": {-
          "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.",
          "format": "int32",
          "type": "integer"
        },
        },

        "backoffLimit": {--
          "description": "Specifies the number of retries before marking this job failed. Defaults to 6",
          "format": "int32",
          "type": "integer"
        }, ### Mas defaults to {Integer}


        "kind": {-
          "description": "kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared",
          "type": "string"
        }, ### No hay una separacion clara de los valores, solo el espacio y dos puntos...

        "imagePullPolicy": {
          "description": "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
          "type": "string" ## por s
        },

--
          "x-kubernetes-validations": { -x
          "description": "x-kubernetes-validations describes a list of validation rules written in the CEL expression language. This field is an alpha-level. Using this field requires the feature gate `CustomResourceValidationExpressions` to be enabled.",
          "items": {
            "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.ValidationRule"
          },
          "type": "array",
          "x-kubernetes-list-map-keys": [
            "rule"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "rule",
          "x-kubernetes-patch-strategy": "merge"
        }
      },
Posible uso:

Validation => expression & !expression.Unspecified

expression.ContainsLineBreaks => message
message => !message.ContainsLineBreaks

(message & messageExpression) => MessageFrom = messageExpression
messageExpression.Invalid => UseDefaultMessage

reason = Unspecified => reason = StatusReasonInvalid
reason => reason ∈ {"Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge"}

    "io.k8s.api.admissionregistration.v1.Validation": { ### CEL-expression con muchos parametros ""
      "description": "Validation specifies the CEL expression which is used to apply the validation.",
      "properties": {
        "expression": {
          "description": "Expression represents the expression which will be evaluated by CEL. ref: https://github.com/google/cel-spec CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:\n\n- 'object' - The object from the incoming request. The value is null for DELETE requests. - 'oldObject' - The existing object. The value is null for CREATE requests. - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)). - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind. - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources. - 'variables' - Map of composited variables, from its name to its lazily evaluated value.\n  For example, a variable named 'foo' can be accessed as 'variables.foo'.\n- 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.\n  See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz\n- 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the\n  request resource.\n\nThe `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the object. No other metadata properties are accessible.\n\nOnly property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible. Accessible property names are escaped according to the following rules when accessed in the expression: - '__' escapes to '__underscores__' - '.' escapes to '__dot__' - '-' escapes to '__dash__' - '/' escapes to '__slash__' - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:\n\t  \"true\", \"false\", \"null\", \"in\", \"as\", \"break\", \"const\", \"continue\", \"else\", \"for\", \"function\", \"if\",\n\t  \"import\", \"let\", \"loop\", \"package\", \"namespace\", \"return\".\nExamples:\n  - Expression accessing a property named \"namespace\": {\"Expression\": \"object.__namespace__ > 0\"}\n  - Expression accessing a property named \"x-prop\": {\"Expression\": \"object.x__dash__prop > 0\"}\n  - Expression accessing a property named \"redact__d\": {\"Expression\": \"object.redact__underscores__d > 0\"}\n\nEquality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1]. Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:\n  - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and\n    non-intersecting elements in `Y` are appended, retaining their partial order.\n  - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values\n    are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with\n    non-intersecting keys are appended, retaining their partial order.\nRequired.",
          "type": "string"
        },
        "message": {
          "description": "Message represents the message displayed when validation fails. The message is required if the Expression contains line breaks. The message must not contain line breaks. If unset, the message is \"failed rule: {Rule}\". e.g. \"must be a URL with the host matching spec.host\" If the Expression contains line breaks. Message is required. The message must not contain line breaks. If unset, the message is \"failed Expression: {Expression}\".",
          "type": "string"
        },
        "messageExpression": {
          "description": "messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails. Since messageExpression is used as a failure message, it must evaluate to a string. If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails. If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged. messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'. Example: \"object.x must be less than max (\"+string(params.max)+\")\"",
          "type": "string"
        },
        "reason": {
          "description": "Reason represents a machine-readable description of why this validation failed. If this is the first validation in the list to fail, this reason, as well as the corresponding HTTP response code, are used in the HTTP response to the client. The currently supported reasons are: \"Unauthorized\", \"Forbidden\", \"Invalid\", \"RequestEntityTooLarge\". If not set, StatusReasonInvalid is used in the response to the client.",
          "type": "string"
        }
      },
      "required": [
        "expression"
      ],
      "type": "object"
    },


    "io.k8s.api.autoscaling.v2.HorizontalPodAutoscalerBehavior": { ### Expresiones un poco mas complejas para mapear pero posibles x-
      "description": "HorizontalPodAutoscalerBehavior configures the scaling behavior of the target in both Up and Down directions (scaleUp and scaleDown fields respectively).",
      "properties": {
        "scaleDown": {
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2.HPAScalingRules",
          "description": "scaleDown is scaling policy for scaling Down. If not set, the default value is to allow to scale down to minReplicas pods, with a 300 second stabilization window (i.e., the highest recommendation for the last 300sec is used)."
        },
        "scaleUp": {
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2.HPAScalingRules",
          "description": "scaleUp is scaling policy for scaling Up. If not set, the default value is the higher of:\n  * increase no more than 4 pods per 60 seconds\n  * double the number of pods per 60 seconds\nNo stabilization is used."
        }
      },
      "type": "object"
    },

      dependences: requires
      "description": "volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim. If specified, the CSI driver will create or update the volume with the attributes defined in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName, it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass will be applied to the claim but it's not allowed to reset this field to empty string once it is set. If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass will be set by the persistentvolume controller if it exists. If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource exists. More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/ (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.",

      "restartPolicy": { # valores sin palabras clave --
        "description": "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
        "type": "string"
      },

      "details": { ### Espacio de mas en una descripcion 
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.StatusDetails",

      ### Valores con comillas invertidas *No las tenia en cuenta
        "parameterNotFoundAction": {
          "description": "`parameterNotFoundAction` controls the behavior of the binding when the resource exists, and name or selector is valid, but there are no parameters matched by the binding. If the value is set to `Allow`, then no matched parameters will be treated as successful validation by the binding. If set to `Deny`, then no matched parameters will be subject to the `failurePolicy` of the policy.\n\nAllowed values are `Allow` or `Deny` Default to `Deny`",
          "type": "string"
        },  ##policy.\n\nAllowed values are `Allow` or `Deny` Default to `Deny`", 

        "immutable": { ### Error en la doc ==> "nil" en vez de null
          "description": "Immutable, if set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Defaulted to nil.",
          "type": "boolean"
        },
This is an alpha field
-x
"description": "ResourceClaim describes which resources are needed by a resource consumer. Its status tracks whether the resource has been allocated and what the resulting attributes are.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate.",

hay varias asi: si se automatiza el encontrar a donde apunta se puede poner un !require (to be false) y un require (to be set)
        "default": y mas...

---Hecho
"description": "strategy specifies how custom resources are converted between versions. Allowed values are: - `\"None\"`: The converter only change the apiVersion and would not touch any other field in the custom resource. - `\"Webhook\"`: API Server will call to an external webhook to do the conversion. Additional information\n  is needed for this option. This requires spec.preserveUnknownFields to be false, and spec.conversion.webhook to be set.",
        "webhook": {
          "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.WebhookConversion",
          "description": "webhook describes how to call the conversion webhook. Required when `strategy` is set to `\"Webhook\"`."
        }
io_k8s_api_networking_v1_IngressClassSpec_parameters_scope_Namespace => io_k8s_api_networking_v1_IngressClassList_items_spec_parameters_namespace
io_k8s_api_networking_v1_IngressClassSpec_parameters_scope_Cluster => !io_k8s_api_networking_v1_IngressClassList_items_spec_parameters_namespace
---Hecho

uvl: feature_strategy_Webhook => feature
Otra descripcion que requiere algo pero no esta en los esquemas..
"description": "lastPhaseTransitionTime is the time the phase transitioned from one to another and automatically resets to current time everytime a volume phase transitions. This is a beta field and requires the PersistentVolumeLastPhaseTransitionTime feature to be enabled (enabled by default)."

## Probando combinaciones ya 'buscadas': requires
This is an alpha field

if this is -- comprobando

The currently supported reasons are:

Valid options are

number is the numerical port number (e.g. 80)

If not set

 --5 constraint de puertos con los numeros validos **intervalos integer: ---Hecho
should be a valid port number (1-65535, inclusive)."
This must be a valid port number, 0 < x < 65536."
If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork
Otro: must be in the range [**]

"port": {  ## En estas descripciones al poder ser integer (número del puerto) o string (nombre del puerto) solo se deberia poder usar la limitacion de los rangos mediante una condicion
  "$ref": "#/definitions/io.k8s.apimachinery.pkg.util.intstr.IntOrString",
  {feature_asInteger} => feature > 1 & feature < 65535
  feature_asString => feature = 'IANA_SVC_NAME'
port name (IANA_SVC_NAME): An alphanumeric (a-z, and 0-9) string, with a maximum length of 15 characters, with the '-' character allowed anywhere except the first or the last character 
or adjacent to another '-' character, it must contain at least a (a-z) character.
  "description": "Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME."
  }
--- Hecho


The currently supported reasons are: (4 pero similares, comillas y barras laterales) --- Hecho
to the client. The currently supported reasons are: \"Unauthorized\", \"Forbidden\", \"Invalid\", \"RequestEntityTooLarge\". If not set, StatusReasonInvalid is used in the response to the client.",
--- Hecho

--- Hecho: Implementacion en el mismo metodo diseñado antes, modificacion del original (con patrones directamente), se pudo agregar las cond directamente
must be greater than, 4
. It must be greater than zero",
PeriodSeconds must be greater than zero and less than or equal to 1800 (30 min).",
down. StabilizationWindowSeconds must be greater than or equal to zero and less than or equal to 3600 (one hour). If not set, use the default values: 
- For scale up: 0 (i.e. no stabilization is done). - For scale down: 300 (i.e. the stabilization window is 300 seconds long).",
"VersionPriority controls the ordering of this API version inside of its group.  Must be greater than zero. The primary
--- Hecho

## Probando combinaciones ya 'buscadas': only if

Default value is [Integer]: Para numeros enteros (revisar) (4 - PREGUNTAR
)
p. This cannot be 0 if MaxSurge is 0 Default value is 1.

---Hecho -> only if type
Can be:
"description": "Type of daemon set update. Can be \"RollingUpdate\" or \"OnDelete\". Default is RollingUpdate.",

Posible constraint entre las 2 propiedades del tipo rollingUpdate y type ** Present only if **
"description": "Rolling update config params. Present only if type = \"RollingUpdate\"."

si el tipo es igual a Rolling update config params "rollingUpdate" esta presente sino no...

feature_type == 'RollingUpdate' => feature_rollingUpdate
feature_type == 'OnDelete' => !feature_rollingUpdate
constraint: io_k8s_api_apps_v1_DaemonSetUpdateStrategy_type_RollingUpdate => io_k8s_api_apps_v1_DaemonSetUpdateStrategy_rollingUpdate
!io_k8s_api_apps_v1_DaemonSetUpdateStrategy_type_RollingUpdate | io_k8s_api_apps_v1_DaemonSetUpdateStrategy_type_OnDelete => !io_k8s_api_apps_v1_DaemonSetUpdateStrategy_rollingUpdate
---Hecho

This list may be empty, but only if `clusterScope` is true." -- constraint (2)

-- Hecho ## añadir valores A value of `

PriorityLevelConfigurationSpec: dependencia entre propiedades, if b == "limited" => a != vacio
This field must be non-empty if and only if `type` is `\"Limited\"`."
io_k8s_api_flowcontrol_v1_PriorityLevelConfiguration_spec_type_Limited => io_k8s_api_flowcontrol_v1_PriorityLevelConfiguration_spec_limited

"description": "`limited` specifies how requests are handled for a Limited priority level. This field must be non-empty if and only if `type` is `\"Limited\"`."

 io_k8s_api_flowcontrol_v1_PriorityLevelConfiguration_spec_type_Limited => io_k8s_api_flowcontrol_v1_PriorityLevelConfiguration_spec_limited

"description": "`exempt` specifies how requests are handled for an exempt priority level. This field MUST be empty if `type` is `\"Limited\"`. This field MAY be non-empty if `type` is `\"Exempt\"`. If empty and `type` is `\"Exempt\"` then the default values for `ExemptPriorityLevelConfiguration` apply."
io_k8s_api_flowcontrol_v1_PriorityLevelConfiguration_spec_type_Limited => !io_k8s_api_flowcontrol_v1_PriorityLevelConfiguration_spec_exempt | io_k8s_api_flowcontrol_v1_PriorityLevelConfiguration_spec_type_Exempt => io_k8s_api_flowcontrol_v1_PriorityLevelConfiguration_spec_exempt 

-- Hecho

fields-to-discriminateBy: caracteristica que indica los features y nombres que "deberian" ser ***

posible constraint: if name == '' => generateName
GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided.
n\nSi se especifica este campo y el nombre generado existe, el servidor devolverá un 409.\n\nSólo se aplica si no se especifica Nombre. se tendria que comprobar si el nombre ya existe en el servidor



"description": "timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == \"ClientIP\". Default value is 10800(for 3 hours).",

Must be set if and only if type is \"Localhost\".", -- Valor por defecto(?)


"fields-to-discriminateBy" ### mirar, podria ser interesante, val x defecto

---Hecho
"description": "localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must be set if type is \"Localhost\". Must NOT be set for any other type.",
# Quitar los alternative con 1 solo valoro tratar de omitir su representacion..
io_k8s_api_apps_v1_StatefulSet_spec_template_spec_topologySpreadConstraints_topologyKey
io_k8s_api_apps_v1_StatefulSet_spec_template_spec_topologySpreadConstraints_minDomains
--- Hecho y comprobando cuales se omiten para detectar si en alguna descripcion hay mas de 1 valor
---Hecho
values:
"description": "status is the status of the ControllerModifyVolume operation. It can be in any of following states:\n - Pending\n   Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as\n   the specified VolumeAttributesClass not existing.\n - InProgress\n   InProgress indicates that the volume is being modified.\n - Infeasible\n  Infeasible indicates that the request has been rejected as invalid by the CSI driver. To\n\t  resolve the error, a valid VolumeAttributesClass needs to be specified.\nNote: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.",
io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_modifyVolumeStatus : mas de un valor
---Hecho

---Hecho \ Faltan restricciones (HECHO-- Localhost)
Valid options are: (2)
Valid options are (5)
"description": "type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. \"ClusterIP\" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is \"None\", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. \"NodePort\" builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. \"LoadBalancer\" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. \"ExternalName\" aliases this service to the specified externalName. Several other fields do not apply to ExternalName services. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types",
---Hecho

Aqui se podria añadir una regla aparte donde se describa que si hay reglas tipo Ingress o Egress se define el policyTypes tambien. -- SIN TERMINAR ESTA PARTE
[\"Ingress\"], [\"Egress\"], or [\"Ingress\", \"Egress\"]. => Si no es especificada, depende del contenido en sus propiedades. or [0..2], con complejidad de relacion

"description": "policyTypes is a list of rule types that the NetworkPolicy relates to. Valid options are [\"Ingress\"], [\"Egress\"], or [\"Ingress\", \"Egress\"]. If this field is not specified, it will default based on the existence of ingress or egress rules; policies that contain an egress section are assumed to affect egress, and all policies (whether or not they contain an ingress section) are assumed to affect ingress. If you want to write an egress-only policy, you must explicitly specify policyTypes [ \"Egress\" ]. Likewise, if you want to write a policy that specifies that no egress is allowed, you must specify a policyTypes value that include \"Egress\" (since such a policy would not include an egress section and would otherwise default to just [ \"Ingress\" ]). This field is beta-level in 1.8",
        
        "persistentVolumeReclaimPolicy": { ## Este quizas saltarlo por la posible obtencion de valores no deseados. Patron con palabra y comas...
          "description": "persistentVolumeReclaimPolicy defines what happens to a persistent volume when released from its claim. Valid options are Retain (default for manually created PersistentVolumes), Delete (default for dynamically provisioned PersistentVolumes), and Recycle (deprecated). Recycle must be supported by the volume plugin underlying this PersistentVolume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming",
          "type": "string"
        },

        },
        "type": { ### Se referencian las 4 "posibles opciones" pero se menciona que Si clusterIP es "None"
          "description": "type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. \"ClusterIP\" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is \"None\", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. \"NodePort\" builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. \"LoadBalancer\" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. \"ExternalName\" aliases this service to the specified externalName. Several other fields do not apply to ExternalName services. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types",
          "type": "string"
        }
---Hecho


--Nuevo--
Valid values are either: Da problemas porque captura un valor no deseado pero tiene otro que puede ser un valor pero String.. Es decir, hay uno definido por defecto y otro libre a usar por el usuario...
Interviene en la expresion que captura los valores de valid options are...

--Nuevo--

--- Hecho
Supports:: añadido
---Hecho

## Revisar la coincidencia entre la descripcion principal y el enum, Revisado y no hay tantas coincidencias como pensaba...
    "io.k8s.api.apps.v1.StatefulSet": { 
      "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n  - Network: A single stable DNS and hostname.\n  - Storage: As many VolumeClaims as requested.\n\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity.",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": [
            "StatefulSet"
          ]
        },

varios valores que no deberian de estar en este feature y otros...
Revisar expresion, enfoque... (patrones en un mismo lugar...): prefixed_keys, example, capacity, values de más. 

											Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResourceStatuses
												alternative
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResourceStatuses_NodeResizePending
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResourceStatuses_NodeResizeFailed
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResourceStatuses_prefixed_keys
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResourceStatuses_NodeResizeInProgress
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResourceStatuses_capacity
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResourceStatuses_storage
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResourceStatuses_example
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResourceStatuses_ControllerResizeFailed
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResourceStatuses_values
											Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResources
												alternative
													String io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResources_asString
													Integer io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResources_asNumber
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResources_prefixed_keys
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResources_example
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResources_values
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResources_storage
											Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_capacity

Nueva xpresion que puede significar mandatory: \n\nRequired"

"description": "`parameterNotFoundAction` controls the behavior of the binding when the resource exists, and name or selector is valid, but there are no parameters matched by the binding. If the value is set to `Allow`, then no matched parameters will be treated as successful validation by the binding. If set to `Deny`, then no matched parameters will be subject to the `failurePolicy` of the policy.\n\nAllowed values are `Allow` or `Deny`\n\nRequired",


Quizas sirva para abrir 2 restricciones beta
and requires the

--- Hecho
          "description": "name is the name of the resource being referenced.\n\nOne of `name` or `selector` must be set, but `name` and `selector` are mutually exclusive properties. If one is set, the other must be unset.\n\nA single parameter used for all admission requests can be configured by setting the `name` field, leaving `selector` blank, and setting namespace if `paramKind` is namespace-scoped.",
restriccions exclusivas con require:
if (feature_name => !feature_selector) & (feature_selector => !feature_name)
--- Hecho

          "description": "namespace is the namespace of the referenced resource. Allows limiting the search for params to a specific namespace. Applies to both `name` and `selector` fields.\n\nA per-namespace parameter may be used by specifying a namespace-scoped `paramKind` in the policy and leaving this field empty.\n\n- If `paramKind` is cluster-scoped, this field MUST be unset. Setting this field results in a configuration error.\n\n- If `paramKind` is namespace-scoped, the namespace of the object being evaluated for admission will be used when this field is left unset. Take care that if this is left empty the binding must not match any cluster-scoped resources, which will result in an error.",

\n\n- If `paramKind` is cluster-scoped, this field MUST be unset. 

Expresion "One of" con mayus


+ Valores:
"description": "`type` is the type of flow distinguisher method The supported types are \"ByUser\" and \"ByNamespace\". Required.",
The supported types are (2 tipos) : 16 insertados

-- Hacer: Insertar como default los enteros que tambien tienen {default} - Hecho
-- Hacer: actualizacion formato de añadir los Boolean -- Pendiente


Descripciones para Rangos Integer y valor por defecto
ClientIPConfig
Default value is 0.
This cannot be 0 if MaxSurge is 0 Default value is 1.
The default value is 10. igual que los otros
"description": "timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == \"ClientIP\". Default value is 10800(for 3 hours).",

terminationGracePeriodSeconds:  ## Complicado para implementar, posibles opciones etc..
Minimum value is 1  rule > 1
Minimum value is (5) para constraints

Defaults to 1
Defaults to 3
Defaults to 6
Defaults to 600
--- Hecho

"description": "appArmorProfile is the AppArmor options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows."

"io.k8s.api.core.v1.AppArmorProfile": {

The profile must be preconfigured on the node to work. Must match the loaded name of the profile.
this field cannot be set when 

spec.os.name
se podria traducir a "io_k8s_api_core_v1_PodSpec_os"
esquema: PodOS => agregar linunx and windows
"description": "Name is the name of the operating system. The currently supported values are linux and windows. Additional value may be defined in future and can be one of: https://github.com/opencontainers/runtime-spec/blob/master/config.md#platform-specific-configuration Clients should expect to handle additional values and treat unrecognized values in this field as os: null",
ref a "os"
"$ref": "#/definitions/io.k8s.api.core.v1.PodOS",
"description": "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup"

feature al que apuntaran los spec.os.name: PodSpec.os
"description": "AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.",
Constraints::
io_k8s_api_core_v1_PodSpec_os_name
io_k8s_api_core_v1_PodSpec_os_name_windows => !io_k8s_api_apps_v1_DaemonSet_spec_template_spec_containers_securityContext_allowPrivilegeEscalation


"description": "The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.",
io_k8s_api_core_v1_PodSpec_os_name_linux => !io_k8s_api_apps_v1_DaemonSet_spec_template_spec_containers_securityContext_windowsOptions
                                             io_k8s_api_apps_v1_DaemonSet_spec_template_spec_os_name_linux
Parte del nombre a coger:: io_k8s_api_apps_v1_DaemonSet_spec_template_spec
Total 1247 features
_spec_template_spec_ 688 features
_template_spec_ (1032) features -- Haciendo


215 pendientes
io_k8s_api_core_v1_Container_securityContext_allowPrivilegeEscalation => no encuentro spec, por defecto esquema general spec_os_name? 
io_k8s_api_core_v1_EphemeralContainer_securityContext_runAsGroup =>igual

io_k8s_api_core_v1_Pod_spec_containers_securityContext_allowPrivilegeEscalation => io_k8s_api_core_v1_Pod_spec_os 
_Pod_spec_ (43 features) --
¿Cada spec.os.name se refiere al esquema general o al propio a cada esquema?
172 restantes
io_k8s_api_core_v1_PodList_items_spec_containers_securityContext_allowPrivilegeEscalation => io_k8s_api_core_v1_PodList_items_spec_os_name 
_PodList_items_spec_ (43) -- Haciendo / Falta parte String, Integer
129 restantes
io_k8s_api_core_v1_PodSpec_containers_securityContext_allowPrivilegeEscalation => io_k8s_api_core_v1_PodSpec_os_name
_core_v1_PodSpec_ (43) -- Haciendo
86 restantes
io_k8s_api_core_v1_PodTemplateSpec_spec_containers_securityContext_allowPrivilegeEscalation => 
_PodTemplateSpec_spec_ (43) -- Haciendo
43 restantes
io_k8s_api_core_v1_Container_securityContext_allowPrivilegeEscalation
_v1_Container_securityContext_ (11)
io_k8s_api_core_v1_EphemeralContainer_securityContext_allowPrivilegeEscalation
_v1_EphemeralContainer_securityContext_ (11)
_PodSecurityContext_ (10) sin spec_os_name
io_k8s_api_core_v1_SecurityContext_allowPrivilegeEscalation => 
_v1_SecurityContext_ _(11) -- Haciendo

0 restantes
Deducciones:
\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups
if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions

    "io.k8s.api.core.v1.SecurityContext": {
      "description": "SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence.",
      "properties": {
        "allowPrivilegeEscalation": {
          "description": "AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.",
          "type": "boolean"
        },
        "appArmorProfile": {
          "$ref": "#/definitions/io.k8s.api.core.v1.AppArmorProfile",
          "description": "appArmorProfile is the AppArmor options to use by this container. If set, this profile overrides the pod's appArmorProfile. Note that this field cannot be set when spec.os.name is windows."
        },
        "capabilities": {
          "$ref": "#/definitions/io.k8s.api.core.v1.Capabilities",
          "description": "The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows."
        },
        "privileged": {
          "description": "Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.",
          "type": "boolean"
        },
        "procMount": {
          "description": "procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.",
          "type": "string"
        },
        "readOnlyRootFilesystem": {
          "description": "Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.",
          "type": "boolean"
        },
        "runAsGroup": {
          "description": "The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.",


          Quizas, valores por defecto:

          If not specified, \"Always\" is used.

- Eliminacion Boolean de los nombres de los features
- Ajuste en los default-Integer con quitar el 0, de 0644..

En lo referente a la adicion de otro nivel en los features donde se ha cambiado el tipo (normlamente String) a Boolean, se focalizan el los features que eran String y podian contener un nombre cualquiera o mencionan uno pero
no especifican qué nombre de esquema coger. Como por ejemplo el siguiente esquema:

    "io.k8s.api.core.v1.AppArmorProfile": {
      "description": "AppArmorProfile defines a pod or container's AppArmor settings.",
      "properties": {
        "localhostProfile": {
          "description": "localhostProfile indicates a profile loaded on the node that should be used. The profile must be preconfigured on the node to work. Must match the loaded name of the profile. Must be set if and only if type is \"Localhost\".",
          "type": "string"
        },
        "type": {
          "description": "type indicates which kind of AppArmor profile will be applied. Valid options are:\n  Localhost - a profile pre-loaded on the node.\n  RuntimeDefault - the container runtime's default profile.\n  Unconfined - no AppArmor enforcement.",
          "type": "string"
        }
      },

Las frases, The profile must be preconfigured on the node to work. Must match the loaded name of the profile., mencionan un posible nombre que ya esta definido antes pero no se especifica el esquema ni se puede deducir...


En otros casos no se indica ningun otro posible valor asi que se deduce que tiene que ser un String "abierto" y que puede tomar cualquier caracter posible. Como para el caso siguiente, namespace al convertirlo a Boolean
no puede coger un valor String ya que se podria nombrar solo diciendo si esta seleccionado o no. Por lo tanto, para estos casos se ha decidido agregar otro nivel de sub-feature donde el que contina será mandatory y String.


    "io.k8s.api.networking.v1.IngressClassParametersReference": {
      "description": "IngressClassParametersReference identifies an API object. This can be used to specify a cluster or namespace-scoped resource.",
      "properties": {
        "apiGroup": {
          "description": "apiGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.",
          "type": "string"
          [...]
        },
        "namespace": {
          "description": "namespace is the namespace of the resource being referenced. This field is required when scope is set to \"Namespace\" and must be unset when scope is set to \"Cluster\".",
          "type": "string"
        },
        "scope": {
          "description": "scope represents if this refers to a cluster or namespace scoped resource. This may be set to \"Cluster\" (default) or \"Namespace\".",
          "type": "string"
        }
      },
Hecho-- Grupo must be between, 22 restricciones: 0<100, 1<30 segs
Adicion de patron para añadir default to integer y restricc
"description": "TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the webhook call will be ignored or the API call will fail based on the failure policy. The timeout value must be between 1 and 30 seconds. Default to 10 seconds.",         
Otra descripc:          
"description": "`lendablePercent` prescribes the fraction of the level's NominalCL that can be borrowed by other priority levels.  This value of this field must be between 0 and 100, inclusive, and it defaults to 0. The number of seats that other levels can borrow from this level, known as this level's LendableConcurrencyLimit (LendableCL), is defined as follows.\n\nLendableCL(i) = round( NominalCL(i) * lendablePercent(i)/100.0 )",
Hecho--
Hecho--
Agregar-pendiente: patron:: Valid operators are
Valid operators are (4):
        "operator": {
          "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
          "type": "string"
        },
Hecho -- 

Hecho--

Constraints grupo Operator
Reglas objetivas: (feature_lastKey_operator_In | feature_lastKey_operator_NotIn (if not-empty) => feature (añadir al grupo de String)) | (feature_lastKey_operator_Exists | feature_lastKey_operator_DoesNotExist (if empty) => !feature)
(feature_lastKey_operator_Gt | feature_lastKey_operator_Lt => feature (deberia ser un array con un unico elemento pero.. o otro feature Integer pero solo esta este caso))
 
        "values": {
          "description": "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
          "items": {
            "type": "string"
          },

Asociado a values => restriccion
        "values": {
          "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
          "items": {
            "type": "string"
          },
Hecho--

Posibles valores (Comprobar**)

        "sideEffects": {
          "description": "SideEffects states whether this webhook has side effects. Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown). Webhooks with side effects MUST implement a reconciliation system, since a request may be rejected by a future step in the admission chain and the side effects therefore need to be undone. Requests with the dryRun attribute will be auto-rejected if they match a webhook with sideEffects == Unknown or Some.",
          "type": "string"
        },
Hecho--

-- Hecho
Más valores:
        "status": {
          "description": "Status of the condition, one of True, False, Unknown.",
          "type": "string"
        },
        "type": {
          "description": "Type of job condition, Complete or Failed.",
          "type": "string"
        }
      },
Hecho--

Hecho--
        "status": {
          "description": "Status of the condition for a component. Valid values for \"Healthy\": \"True\", \"False\", or \"Unknown\".",
          "type": "string"
        },
        "type": {
          "description": "Type of condition for a component. Valid value: \"Healthy\"", ### Si es un unico valor añadir como optional no?... u mandatory si especifica que es el unico? ### PREGUNTAR SI HAY COND IGUAL
          "type": "string"
        }
Pendiente una cosa--

Hecho--
        "status": {
          "description": "`status` is the status of the condition. Can be True, False, Unknown. Required.",
          "type": "string"
        },
        "type": {
          "description": "`type` is the type of the condition. Required.",
          "type": "string"
        }
        "description": "status is the status of the condition (True, False, Unknown)",
Hecho--

Hecho--
"description": "Node address type, one of Hostname, ExternalIP or InternalIP.",

        "preemptionPolicy": { # En esta hay una restric con el default dependiendo de si no se escoge
          "description": "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.",
          "type": "string"
        },

        "restartPolicy": { ## En esta hay una restric con el default dependiendo de que cambia...
          "description": "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
          "type": "string"
        },
Hecho--

Hecho-- 
Valores... y una restricc simple / type is the type of metric source y Note: \"ContainerResource\" type is available on when the feature-gate HPAContainerMetrics is enabled
## Ignorando HPAContainerMetrics porque no se encontro donde se menciona en las descripciones o a que propiedad pertenece
        "type": {
          "description": "type is the type of metric source.  It should be one of \"ContainerResource\", \"External\", \"Object\", \"Pods\" or \"Resource\", each mapping to a matching field in the object. Note: \"ContainerResource\" type is available on when the feature-gate HPAContainerMetrics is enabled",
          "type": "string"
        }
},
        "type": {
          "description": "type is the type of metric source.  It will be one of \"ContainerResource\", \"External\", \"Object\", \"Pods\" or \"Resource\", each corresponds to a matching field in the object. Note: \"ContainerResource\" type is available on when the feature-gate HPAContainerMetrics is enabled",
          "type": "string"
        }
      },
Hecho--

aparte::

Hecho--

"description": "auditAnnotations contains CEL expressions which are used to produce audit annotations for the audit event of the API request. validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is required.",
restrict:
validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is required
feature_validations | feature_auditAnnotations \ feature_validations & feature_auditAnnotations 

restric en feature principal: ## Para integrar el uso de la siguiente restrict se deberia de usar la misma metodologia de añadir un sub-nivel mas al Integer y convertir ese feature a Boolean
      "description": "SelfSubjectAccessReviewSpec is a description of the access request.  Exactly one of ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set",

      -- (metodo con sus nombres)"description": "SubjectAccessReviewSpec is a description of the access request.  Exactly one of ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set",
      --"description": "url gives the location of the webhook, in standard URL form (`scheme://host:port/path`). Exactly one of `url` or `service` must be specified.\n\nThe `host` should not refer to a service running in the cluster; use the `service` field instead. The host might be resolved via external DNS in some apiservers (e.g., `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation). `host` may also be an IP address.\n\nPlease note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take great care to run this webhook on all hosts which run an apiserver which might need to make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy to turn up in a new cluster.\n\nThe scheme must be \"https\"; the URL must begin with \"https://\".\n\nA path is optional, and if present may be any string permissible in a URL. You may use the path to pass an arbitrary string to the webhook, for example, a cluster identifier.\n\nAttempting to use a user or basic auth e.g. \"user:password@\" is not allowed. Fragments (\"#...\") and query parameters (\"?...\") are not allowed, either.",

      "description": "SuccessPolicyRule describes rule for declaring a Job as succeeded. Each rule must have at least one of the \"succeededIndexes\" or \"succeededCount\" specified.",
      "properties": { ## No se si añadir una restric mas compleja en el caso de que los 2 esten up... => Solo se usa succeededIndexes en ese caso?
        "succeededCount": { 
          "description": "succeededCount specifies the minimal required size of the actual set of the succeeded indexes for the Job. When succeededCount is used along with succeededIndexes, the check is constrained only to the set of indexes specified by succeededIndexes. For example, given that succeededIndexes is \"1-4\", succeededCount is \"3\", and completed indexes are \"1\", \"3\", and \"5\", the Job isn't declared as succeeded because only \"1\" and \"3\" indexes are considered in that rules. When this field is null, this doesn't default to any value and is never evaluated at any time. When specified it needs to be a positive integer.",
          "format": "int32",
          "type": "integer"
        },
        "succeededIndexes": {
          "description": "succeededIndexes specifies the set of indexes which need to be contained in the actual set of the succeeded indexes for the Job. The list of indexes must be within 0 to \".spec.completions-1\" and must not contain duplicates. At least one element is required. The indexes are represented as intervals separated by commas. The intervals can be a decimal integer or a pair of decimal integers separated by a hyphen. The number are listed in represented by the first and last element of the series, separated by a hyphen. For example, if the completed indexes are 1, 3, 4, 5 and 7, they are represented as \"1,3-5,7\". When this field is null, this field doesn't default to any value and is never evaluated at any time.",
          "type": "string"
        }
      },
A partir de esta restric se han quedado 2 descripciones sin obtener una regla => 2 minus at least of...
      --"description": "`resourceRules` is a slice of ResourcePolicyRules that identify matching requests according to their verb and the target resource. At least one of `resourceRules` and `nonResourceRules` has to be non-empty.",
Hecho--


Restric compleja: -  PENDIENTE
      "description": "The latest available observations of an object's current state. When a Job fails, one of the conditions will have type \"Failed\" and status true. When a Job is suspended, one of the conditions will have type \"Suspended\" and status true; when the Job is resumed, the status of this condition will become false. When a Job is completed, one of the conditions will have type \"Complete\" and status true.\n\nA job is considered finished when it is in a terminal condition, either \"Complete\" or \"Failed\". A Job cannot have both the \"Complete\" and \"Failed\" conditions. Additionally, it cannot be in the \"Complete\" and \"FailureTarget\" conditions. The \"Complete\", \"Failed\" and \"FailureTarget\" conditions cannot be disabled.\n\nMore info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/",

Otra:      
      -- Hecho "description": "PodFailurePolicyRule describes how a pod failure is handled when the requirements are met. One of onExitCodes and onPodConditions, but not both, can be used in each rule.",


-- Hecho
        "status": {
          "description": "status of the condition, one of True, False, Unknown. Approved, Denied, and Failed conditions may not be \"False\" or \"Unknown\".",
          "type": "string"
        }, regla: feature_Approved => !feature_False | !feature_Unknown      feature_Denied => !feature_False | !feature_Unknown      feature_Failed => !feature_False | !feature_Unknown
        Objetivo:
        feature_Approved => not (feature_False or feature_Unknown)
        feature_Denied => not (feature_False or feature_Unknown)
        feature_Failed => not (feature_False or feature_Unknown)

        "type": { 
          "description": "type of the condition. Known conditions are \"Approved\", \"Denied\", and \"Failed\".\n\nAn \"Approved\" condition is added via the /approval subresource, indicating the request was approved and should be issued by the signer.\n\nA \"Denied\" condition is added via the /approval subresource, indicating the request was denied and should not be issued by the signer.\n\nA \"Failed\" condition is added via the /status subresource, indicating the signer failed to issue the certificate.\n\nApproved and Denied conditions are mutually exclusive. Approved, Denied, and Failed conditions cannot be removed once added.\n\nOnly one condition of a given type is allowed.",
          "type": "string"
        }
-- Hecho

-- Hecho
      "io.k8s.api.core.v1.ClaimSource": {
      "description": "ClaimSource describes a reference to a ResourceClaim.\n\nExactly one of these fields should be set.  Consumers of this type must treat an empty object as if it has an unknown value.",
      "properties": {
        "resourceClaimName": {
          "description": "ResourceClaimName is the name of a ResourceClaim object in the same namespace as this pod.",
          "type": "string"
        },
        "resourceClaimTemplateName": {
          "description": "ResourceClaimTemplateName is the name of a ResourceClaimTemplate object in the same namespace as this pod.\n\nThe template will be used to create a new ResourceClaim, which will be bound to this pod. When this pod is deleted, the ResourceClaim will also be deleted. The pod name and resource name, along with a generated component, will be used to form a unique name for the ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.\n\nThis field is immutable and no changes will be made to the corresponding ResourceClaim by the control plane after creating the ResourceClaim.",
          "type": "string"
        }
      },
      "type": "object"
    },

      "imagePullPolicy": { 3 valores ya añadidos (Restric?)
        "description": "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
        "type": "string"
      },
-- Hecho

    Restricciones multiples de que solo uno de los 3 puede ser seleccionado

-- Hecho
1º Restric compleja, objetivo:
# Exclusividad: Solo un estado a la vez
(featureWaiting => !featureRunning & !featureTerminated)
& (featureRunning => !featureStateWaiting & !featureStateTerminated)
& (featureTerminated => !featureStateWaiting & !featureStateRunning)

# Valor por defecto: Si ninguno está seleccionado, se asume ContainerStateWaiting
!ContainerStateRunning & !ContainerStateTerminated => ContainerStateWaiting

    "io.k8s.api.core.v1.ContainerState": {
        "description": "ContainerState holds a possible state of container. Only one of its members may be specified. If none of them is specified, the default one is ContainerStateWaiting.",
-- Hecho

-- Hecho -(pendiente comprobar...)
Creo que no se puede aplicar una regla a la siguiente: // Se puede, hay un should be considered deprecated
    "io.k8s.api.core.v1.FlockerVolumeSource": {
      "description": "Represents a Flocker volume mounted by the Flocker agent. One and only one of datasetName and datasetUUID should be set. Flocker volumes do not support ownership management or SELinux relabeling.",
-- Hecho (falta comprobar la sintaxis en el lab)
## Hay un deprecated mostrado por compatibilidad => no se selecciona
Objetivo:
(feature_exec | feature_httpGet | feature_sleep) & (!feature_exec & !feature_httpGet & !feature_sleep) & !feature_tcpScket
!feature_tcpScket: deprecated
Nuevo obj:
(feature_exec | feature_httpGet | feature_sleep) &
!(feature_exec & feature_httpGet) &
!(feature_exec & feature_sleep) &
!(feature_httpGet & feature_sleep) &
!feature_tcpSocket

    "io.k8s.api.core.v1.LifecycleHandler": {
      "description": "LifecycleHandler defines a specific action that should be taken in a lifecycle hook. One and only one of the fields, except TCPSocket must be specified.",
      "properties": {
        "exec": {
          "$ref": "#/definitions/io.k8s.api.core.v1.ExecAction",
          "description": "Exec specifies the action to take."
        },
        "httpGet": {
          "$ref": "#/definitions/io.k8s.api.core.v1.HTTPGetAction",
          "description": "HTTPGet specifies the http request to perform."
        },
        "sleep": {
          "$ref": "#/definitions/io.k8s.api.core.v1.SleepAction",
          "description": "Sleep represents the duration that the container should sleep before being terminated."
        },
        "tcpSocket": {
          "$ref": "#/definitions/io.k8s.api.core.v1.TCPSocketAction",
          "description": "Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified."
        }
      },
-- Hecho
**Revisar los Deprecated.**
-- Haciendo
        "externalTrafficPolicy": {
          "description": "externalTrafficPolicy describes how nodes distribute service traffic they receive on one of the Service's \"externally-facing\" addresses (NodePorts, ExternalIPs, and LoadBalancer IPs). If set to \"Local\", the proxy will configure the service in a way that assumes that external load balancers will take care of balancing the service traffic between nodes, and so each node will deliver traffic only to the node-local endpoints of the service, without masquerading the client source IP. (Traffic mistakenly sent to a node with no endpoints will be dropped.) The default value, \"Cluster\", uses the standard behavior of routing to all endpoints evenly (possibly modified by topology and other features). Note that traffic sent to an External IP or LoadBalancer IP from within the cluster will always get \"Cluster\" semantics, but clients sending to a NodePort from within the cluster may need to take traffic policy into account when picking a node.",
          "type": "string"
        },

        "ipFamilyPolicy": {
          "description": "IPFamilyPolicy represents the dual-stack-ness requested or required by this Service. If there is no value provided, then this field will be set to SingleStack. Services can be \"SingleStack\" (a single IP family), \"PreferDualStack\" (two IP families on dual-stack configured clusters or a single IP family on single-stack clusters), or \"RequireDualStack\" (two IP families on dual-stack configured clusters, otherwise fail). The ipFamilies and clusterIPs fields depend on the value of this field. This field will be wiped when updating a service to type ExternalName.",
          "type": "string"
        },


        "ipFamilies": {
          "description": "IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this service. This field is usually assigned automatically based on cluster configuration and the ipFamilyPolicy field. If this field is specified manually, the requested family is available in the cluster, and ipFamilyPolicy allows it, it will be used; otherwise creation of the service will fail. This field is conditionally mutable: it allows for adding or removing a secondary IP family, but it does not allow changing the primary IP family of the Service. Valid values are \"IPv4\" and \"IPv6\".  This field only applies to Services of types ClusterIP, NodePort, and LoadBalancer, and does apply to \"headless\" services. This field will be wiped when updating a Service to type ExternalName.\n\nThis field may hold a maximum of two entries (dual-stack families, in either order).  These families must correspond to the values of the clusterIPs field, if specified. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.",
          "items": {
            "type": "string"
        },

-- Hecho // ya estaba hecha
        "resourceRules": {
          "description": "`resourceRules` is a slice of ResourcePolicyRules that identify matching requests according to their verb and the target resource. At least one of `resourceRules` and `nonResourceRules` has to be non-empty.",
          "items": {
            "$ref": "#/definitions/io.k8s.api.flowcontrol.v1.ResourcePolicyRule"
          },

-- Hecho
Objetivo restric:
feature_kind == "Group" => feature_group | feature_kind == "ServiceAccount" => feature_serviceAccount | feature_kind == "User" => feature_user 
& !(feature_group & feature_serviceAccount) & !(feature_group & feature_user) & !(feature_serviceAccount & feature_user)
    "io.k8s.api.flowcontrol.v1.Subject": { ## Se podria añadir manualmente los valores posibles de kind {"Group","ServiceAccount","User"} pero lo hare direc con string por si hay algun valor mas que pueda haber
      "description": "Subject matches the originator of a request, as identified by the request authentication system. There are three ways of matching an originator; by user, group, or service account.",
      "properties": {
        "group": {
          "$ref": "#/definitions/io.k8s.api.flowcontrol.v1.GroupSubject",
          "description": "`group` matches based on user group name."
        },
        "kind": {
          "description": "`kind` indicates which one of the other fields is non-empty. Required",
          "type": "string"
        },
        "serviceAccount": {
          "$ref": "#/definitions/io.k8s.api.flowcontrol.v1.ServiceAccountSubject",
          "description": "`serviceAccount` matches ServiceAccounts."
        },
        "user": {
          "$ref": "#/definitions/io.k8s.api.flowcontrol.v1.UserSubject",
          "description": "`user` matches based on username."
        }
      },
      "required": [
        "kind"
      ],
      "type": "object",
      "x-kubernetes-unions": [
        {
          "discriminator": "kind",
          "fields-to-discriminateBy": {
            "group": "Group",
            "serviceAccount": "ServiceAccount",
            "user": "User"
          }
        }
-- Hecho

Se puede usar la cardinalidad para el numero posible de features que se pueden crear?

        "cidrs": {
          "description": "CIDRs defines the IP blocks in CIDR notation (e.g. \"192.168.0.0/24\" or \"2001:db8::/64\") from which to assign service cluster IPs. Max of two CIDRs is allowed, one of each IP family. This field is immutable.",
          "items": {
            "type": "string"
          },

-- Hecho (valores)
        "preemptionPolicy": {
          "description": "preemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.",
          "type": "string"
        },


          "description": "url gives the location of the webhook, in standard URL form (`scheme://host:port/path`). Exactly one of `url` or `service` must be specified.\n\nThe `host` should not refer to a service running in the cluster; use the `service` field instead. The host might be resolved via external DNS in some apiservers (e.g., `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation). `host` may also be an IP address.\n\nPlease note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take great care to run this webhook on all hosts which run an apiserver which might need to make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy to turn up in a new cluster.\n\nThe scheme must be \"https\"; the URL must begin with \"https://\".\n\nA path is optional, and if present may be any string permissible in a URL. You may use the path to pass an arbitrary string to the webhook, for example, a cluster identifier.\n\nAttempting to use a user or basic auth e.g. \"user:password@\" is not allowed. Fragments (\"#...\") and query parameters (\"?...\") are not allowed, either.",

        "status": { 
          "description": "Status of the operation. One of: \"Success\" or \"Failure\". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "type": "string"
        }
-- Hecho(valores)

-- Hecho
## Parecido al Exempt (por el type)
      "properties": {
        "queuing": {
          "$ref": "#/definitions/io.k8s.api.flowcontrol.v1beta3.QueuingConfiguration",
          "description": "`queuing` holds the configuration parameters for queuing. This field may be non-empty only if `type` is `\"Queue\"`."
        },
        "type": {
          "description": "`type` is \"Queue\" or \"Reject\". \"Queue\" means that requests that can not be executed upon arrival are held in a queue until they can be executed or a queuing limit is reached. \"Reject\" means that requests that can not be executed upon arrival are rejected. Required.",
          "type": "string"
        }
      },
      "required": [
        "type"
      ],
      "type": "object",
      "x-kubernetes-unions": [
        {
          "discriminator": "type",
          "fields-to-discriminateBy": {
            "queuing": "Queuing"
          }
        }
      ]
-- Hecho

-- Hecho
Hay features que dependiendo del contexto mencionan unos posibles valores u otros asociados a un sub-feature(template.spec.restartPolicy):
_spec_restartPolicy...
Objetivo:
feature => feature_spec_restartPolicy_{valor} & !feature_spec_restartPolicy_{otrosValores}
Dependiendo del contexto de los esquemas se permiten un valor o varios dentro del .restartPolicy, si se usa ReplicationController solo se permite el Always:
io_k8s_api_core_v1_ReplicationController_spec_template_spec_restartPolicy == ..._Always : se pone antes de introducir el template para que vaya con esa condicion dentro del esquema...
ReplicationController => esquemaFeature_ReplicationController...Always & !Never & !OnFailure (probar restricciones)

        "template": {
          "$ref": "#/definitions/io.k8s.api.core.v1.PodTemplateSpec",
          "description": "An object that describes the pod that will be created. The DaemonSet will create exactly one copy of this pod on every node that matches the template's node selector (or on every node if no node selector is specified). The only allowed template.spec.restartPolicy value is \"Always\". More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template"
        },

        },
        "template": {
          "$ref": "#/definitions/io.k8s.api.core.v1.PodTemplateSpec",
          "description": "Template describes the pods that will be created. The only allowed template.spec.restartPolicy value is \"Always\"."
        }
      },

      },
        "template": {
          "$ref": "#/definitions/io.k8s.api.core.v1.PodTemplateSpec",
          "description": "Describes the pod that will be created when executing a job. The only allowed template.spec.restartPolicy values are \"Never\" or \"OnFailure\". More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/"
      },

-- Hecho      
"description": "Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.", (444)

PodSpec.nodeName

        "endpoints": { ## harian falta numerar los items o tener un control sobre objetos/listas
          "description": "endpoints is a list of unique endpoints in this slice. Each slice may include a maximum of 1000 endpoints.",
          "items": {
            "$ref": "#/definitions/io.k8s.api.discovery.v1.Endpoint"
          },


        "selectableFields": { ## este es igual que el anterior, maximo de 8 selectableFields que se podrian crear
          "description": "selectableFields specifies paths to fields that may be used as field selectors. A maximum of 8 selectable fields are allowed. See https://kubernetes.io/docs/concepts/overview/working-with-objects/field-selectors",
          "items": {
            "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.SelectableField"
          },
          "type": "array",
          "x-kubernetes-list-type": "atomic"
        },

        ## Igual que los anteriores:

                "matchConditions": {
          "description": "MatchConditions is a list of conditions that must be met for a request to be sent to this webhook. Match conditions filter requests that have already been matched by the rules, namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests. There are a maximum of 64 match conditions allowed.\n\nThe exact matching logic is (in order):\n  1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.\n  2. If ALL matchConditions evaluate to TRUE, the webhook is called.\n  3. If any matchCondition evaluates to an error (but none are FALSE):\n     - If failurePolicy=Fail, reject the request\n     - If failurePolicy=Ignore, the error is ignored and the webhook is skipped",
          "items": {
            "$ref": "#/definitions/io.k8s.api.admissionregistration.v1.MatchCondition"
          },
          "type": "array",
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
It's a required field


may have 3 possible values:
        "x-kubernetes-list-type": {
          "description": "x-kubernetes-list-type annotates an array to further describe its topology. This extension must only be used on lists and may have 3 possible values:\n\n1) `atomic`: the list is treated as a single entity, like a scalar.\n     Atomic lists will be entirely replaced when updated. This extension\n     may be used on any type of list (struct, scalar, ...).\n2) `set`:\n     Sets are lists that must not have multiple items with the same value. Each\n     value must be a scalar, an object with x-kubernetes-map-type `atomic` or an\n     array with x-kubernetes-list-type `atomic`.\n3) `map`:\n     These lists are like maps in that their elements have a non-index key\n     used to identify them. Order is preserved upon merge. The map tag\n     must only be used on a list with elements of type object.\nDefaults to atomic for arrays.",
          "type": "string"
        },
        "x-kubernetes-map-type": {
          "description": "x-kubernetes-map-type annotates an object to further describe its topology. This extension must only be used when type is object and may have 2 possible values:\n\n1) `granular`:\n     These maps are actual maps (key-value pairs) and each fields are independent\n     from each other (they can each be manipulated by separate actors). This is\n     the default behaviour for all maps.\n2) `atomic`: the list is treated as a single entity, like a scalar.\n     Atomic maps will be entirely replaced when updated.",
          "type": "string"
        },



Defaults to:

            "listKind": {
        "description": "listKind is the serialized kind of the list for this resource. Defaults to \"`kind`List\".",
        "type": "string"
      },


        "singular": {
          "description": "singular is the singular name of the resource. It must be all lowercase. Defaults to lowercased `kind`.",
          "type": "string"
        }

minimum valid value
"description": "expirationSeconds is the requested duration of validity of the issued certificate. The certificate signer may issue a certificate with a different validity duration so a client must check the delta between the notBefore and and notAfter fields in the issued certificate to determine the actual duration.\n\nThe v1.22+ in-tree implementations of the well-known Kubernetes signers will honor this field as long as the requested duration is not greater than the maximum duration they will honor per the --cluster-signing-duration CLI flag to the Kubernetes controller manager.\n\nCertificate signers may not honor this field for various reasons:\n\n  1. Old signer that is unaware of the field (such as the in-tree\n     implementations prior to v1.22)\n  2. Signer whose configured maximum is shorter than the requested duration\n  3. Signer whose configured minimum is longer than the requested duration\n\nThe minimum valid value for expirationSeconds is 600, i.e. 10 minutes.",

Minimum_Max

--Hecho
1 - 1295 restricciones
2 - (3)
3 - (36)
4 - (92)
Mediante estos grupos de restricciones se generaron las siguientes:
En total se generaron 4 restricciones del siguiente grupo:
Objetivo:
feature > 1 (1295)
          "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
          "format": "int32",
          "type": "integer"
        }   ## quizas se pueda añadir una restriccion que comprenda entre 1 < X. default to 10, minimum 1
Value must be non-negative (36)
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",

spec.terminationGracePeriodSeconds == PodSpec.terminationGracePeriodSeconds
!feature_Probe_terminationGracePeriodSeconds => PodSpec.terminationGracePeriodSeconds

!feature_Probe_terminationGracePeriodSeconds => feature_Probe_terminationGracePeriodSeconds = spec.terminationGracePeriodSeconds (PodSpec.terminationGracePeriodSeconds)

        "terminationGracePeriodSeconds": { -x
          "description": "Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.",
          "format": "int64",
          "type": "integer"
        },



The maximum size of this field is 16KiB: se define por un valor string y no por Integer...
          "description": "Data contains the opaque data associated with this ResourceHandle. It is set by the controller component of the resource driver whose name matches the DriverName set in the ResourceClaimStatus this ResourceHandle is embedded in. It is set at allocation time and is intended for processing by the kubelet plugin whose name matches the DriverName set in this ResourceHandle.\n\nThe maximum size of this field is 16KiB. This may get increased in the future, but not reduced.",

. The keys cannot be empty, and the maximum number of parameters is 512, with a cumulative max size of 256K. If the CSI driver rejects invalid parameters,
Valores:
-x

-- Hecho
"description": "cachingMode is the Host Caching mode: None, Read Only, Read Write.",

        "kind": {
          "description": "kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared",
          "type": "string"
        },
-- Hecho

range: -- Hecho
            "weight": {
          "description": "Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.", (92)
          "format": "int32",
          "type": "integer"
        }
        
Se podrian obtener las siguientes conclusiones de la descripcion (si se pudiese referenciar al valor del feature):

  (spec.ordinals.start, .spec.ordinals.start + .spec.replicas).\nIf unset, defaults to 0. 
  
  Replica indices will be in the range:\n  [0, .spec.replicas).
  
  spec_ordinals_start // _StatefulSetList_items_spec_ordinals_start -- _StatefulSetList_items_spec_replicas
  
La sintaxis uvl no esta preparada para realizar este tipo de restricciones y obtención de los valores:
(io_k8s_api_apps_v1_StatefulSetList_items_spec_ordinals_start < (io_k8s_api_apps_v1_StatefulSetList_items_spec_ordinals_start + io_k8s_api_apps_v1_StatefulSetList_items_spec_replicas))


        "start": {
          "description": "start is the number representing the first replica's index. It may be used to number replicas from an alternate index (eg: 1-indexed) over the default 0-indexed names, or to orchestrate progressive movement of replicas from one StatefulSet to another. If set, replica indices will be in the range:\n  [.spec.ordinals.start, .spec.ordinals.start + .spec.replicas).\nIf unset, defaults to 0. Replica indices will be in the range:\n  [0, .spec.replicas).",
          "format": "int32",
          "type": "integer"
        }

-x

Otros:
        "failurePolicy": {
          "description": "failurePolicy defines how to handle failures for the admission policy. Failures can occur from CEL expression parse errors, type check errors, runtime errors and invalid or mis-configured policy definitions or bindings.\n\nA policy is invalid if spec.paramKind refers to a non-existent Kind. A binding is invalid if spec.paramRef.name refers to a non-existent resource.\n\nfailurePolicy does not define how validations that evaluate to false are handled.\n\nWhen failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions define how failures are enforced.\n\nAllowed values are Ignore or Fail. Defaults to Fail.",
          "type": "string"
        },


Ajustes analizando Dead Features:
    io_k8s_api_admissionregistration_v1_ParamRef_name: deberia de tener un sub nivel con mandatory y string
    error detectado en mala sintaxis con el segundo feature...

Segundo tramo de features Always, OnFailure y Never:
Hay Dead Features porque nunca se seleccionan las que no se usan, OnFailure y Never => Dead Features. Always en segundo tramo
Quizas simplificar mas al tenerlo como alternative: (io_k8s_api_apps_v1_DaemonSet_spec_template => io_k8s_api_apps_v1_DaemonSet_spec_template_spec_restartPolicy_Always)

Tercer grupo de deads:

feature_Approved => not (feature_False or feature_Unknown)
Se forman dead features porque limitamos la seleccion de las opciones a las que no se pueden...

Sleep Represents: Causaba varios dead features y falses por generallizar el que no se use en LifecycleHandler. Lo aplicaba a todos y eso causaba el conflicto con otras restricciones de rangos etc
Error solucionado añadiendo el condicional para que solo se agregue en el caso especifico

        """(feature_exec | feature_httpGet | feature_sleep) &
        !(feature_exec & feature_httpGet) &
        !(feature_exec & feature_sleep) &
        !(feature_httpGet & feature_sleep) &
        !feature_tcpSocket"""


        "conditions may not be"

            ##uvl_rule = uvl_rule.strip()
        """ feature_Approved => not (feature_False or feature_Unknown) ## objetivo # Nota añadida: generan Dead Features
            feature_Denied => not (feature_False or feature_Unknown)
            feature_Failed => not (feature_False or feature_Unknown)"""

""" for condition in conditions_match: # como antes
        print("Valor condition", condition)
        uvl_rule += f"{feature_without_lastProperty} => ({feature_without_lastProperty}_type_{condition} => {types_notbe})\n"""
        

""oneOf()

        """ feature_kind == "Group" => feature_group 
        | feature_kind == "ServiceAccount" => feature_serviceAccount 
        | feature_kind == "User" => feature_user 
        & !(feature_group & feature_serviceAccount) & !(feature_group & feature_user) & !(feature_serviceAccount & feature_user)"""
"conditions may not be"
: Modificado: de 12 a 4 constraints involucradas. Se ignora el tpSocket de esta propiedad del feature por derpecated





COMPARACIÓN MODELO GENERADO AUTO. CON MODELO MANUAL DESDE LA DOC..(Enrique)

Core features auto: 0

"group": "admission.k8s.io": objetos donde se definen los grupos y versiones... vienen en el nombre inhibidas


Core features manifes: 2 (apiVersion y kind)


Comprobando las versiones de objetos donde se definen varias, hay versiones que no estan en la doc o no se mencionan...
        {
          "group": "storage.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1beta1"
        },

Diferencias con el modelo de Enrique:
Definicion de ApiVersion y kind como features con los valores posibles. "Creo" que en mi versión no hace falta porque los grupos y las versiones a los que pertenecen los features vienen inhibidos en el nombre del feature tambien

features de tipo Array como cardinatility // en el mio se usa como Boolean