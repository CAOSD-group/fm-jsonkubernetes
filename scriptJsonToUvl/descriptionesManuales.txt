key specifies the audit annotation key. The audit annotation keys of a ValidatingAdmissionPolicy must be unique. The key must be a qualified name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
valueExpression represents the expression which is evaluated by CEL to produce an audit annotation value. The expression must evaluate to either a string or null value. If the expression evaluates to a string, the audit annotation is included with the string value. If the expression evaluates to null or empty string the audit annotation will be omitted. The valueExpression may be no longer than 5kb in length. If the result of the valueExpression is more than 10kb in length, it will be truncated to 10kb.

Name is an identifier for this match condition, used for strategic merging of MatchConditions, as well as providing an identifier for logging purposes. A good name should be descriptive of the associated expression. Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or * for all of those operations and any future admission operations that are added. If '*' is present, the length of the slice must be one. Required.
scope specifies the scope of this rule. Valid values are "Cluster", "Namespaced", and "*" "Cluster" means that only cluster-scoped resources will match this rule. Namespace API objects are cluster-scoped. "Namespaced" means that only namespaced resources will match this rule. "*" means that there are no scope restrictions. Subresources match the scope of their parent resource. Default is "*".

matchPolicy defines how the "MatchResources" list is used to match incoming requests. Allowed values are "Exact" or "Equivalent".
- Exact: match a request only if it exactly matches a specified rule. For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.

- Equivalent: match a request if modifies a resource listed in rules, even via another API group or version. For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.

Defaults to "Equivalent"

matchExpressions is a list of label selector requirements. The requirements are ANDed.
operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.

ClientConfig defines how to communicate with the hook. Required
`caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate. If unspecified, system trust roots on the apiserver are used.
`service` is a reference to the service for this webhook. Either `service` or `url` must be specified.
If specified, the port on the service that hosting webhook. Default to 443 for backward compatibility. `port` should be a valid port number (1-65535, inclusive).
FailurePolicy defines how unrecognized errors from the admission endpoint are handled - allowed values are Ignore or Fail. Defaults to Fail.
reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation. Allowed values are "Never" and "IfNeeded".

Never: the webhook will not be called more than once in a single admission evaluation.

IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation if the object being admitted is modified by other admission plugins after the initial webhook call. Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted. Note: * the number of additional invocations is not guaranteed to be exactly one. * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again. * webhooks that use this option may be reordered to minimize the number of additional invocations. * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
Defaults to "Never".
SideEffects states whether this webhook has side effects. Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown). Webhooks with side effects MUST implement a reconciliation system, since a request may be rejected by a future step in the admission chain and the side effects therefore need to be undone. Requests with the dryRun attribute will be auto-rejected if they match a webhook with sideEffects == Unknown or Some.

TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the webhook call will be ignored or the API call will fail based on the failure policy. The timeout value must be between 1 and 30 seconds. Default to 10 seconds.
FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: "FieldsV1"
Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.
One of `name` or `selector` must be set, but `name` and `selector` are mutually exclusive properties. If one is set, the other must be unset.
name is the name of the resource being referenced.

One of `name` or `selector` must be set, but `name` and `selector` are mutually exclusive properties. If one is set, the other must be unset.

A single parameter used for all admission requests can be configured by setting the `name` field, leaving `selector` blank, and setting namespace if `paramKind` is namespace-scoped.
namespace is the namespace of the referenced resource. Allows limiting the search for params to a specific namespace. Applies to both `name` and `selector` fields.
A per-namespace parameter may be used by specifying a namespace-scoped `paramKind` in the policy and leaving this field empty.

- If `paramKind` is cluster-scoped, this field MUST be unset. Setting this field results in a configuration error.

- If `paramKind` is namespace-scoped, the namespace of the object being evaluated for admission will be used when this field is left unset. Take care that if this is left empty the binding must not match any cluster-scoped resources, which will result in an error.
`parameterNotFoundAction` controls the behavior of the binding when the resource exists, and name or selector is valid, but there are no parameters matched by the binding. If the value is set to `Allow`, then no matched parameters will be treated as successful validation by the binding. If set to `Deny`, then no matched parameters will be subject to the `failurePolicy` of the policy.

Allowed values are `Allow` or `Deny`

One of `name` or `selector` must be set, but `name` and `selector` are mutually exclusive properties. If one is set, the other must be unset.


Required
    
    "io_k8s_api_admissionregistration_v1_ValidatingAdmissionPolicy_status_conditions_status": "status of the condition, one of True, False, Unknown.",
    "io_k8s_api_admissionregistration_v1_ValidatingAdmissionPolicy_status_conditions_type": "type of condition in CamelCase or in foo.example.com/CamelCase.",

    "io_k8s_api_apps_v1_DaemonSet_spec_template_spec_volumes_awsElasticBlockStore_fsType": "fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore",
    
    "io_k8s_api_autoscaling_v2_HorizontalPodAutoscaler_spec_metrics_type": "type is the type of metric source.  It should be one of \"ContainerResource\", \"External\", \"Object\", \"Pods\" or \"Resource\", each mapping to a matching field in the object. Note: \"ContainerResource\" type is available on when the feature-gate HPAContainerMetrics is enabled",

    "io_k8s_api_autoscaling_v1_HorizontalPodAutoscaler_spec_minReplicas": "minReplicas is the lower limit for the number of replicas to which the autoscaler can scale down.  It defaults to 1 pod.  minReplicas is allowed to be 0 if the alpha feature gate HPAScaleToZero is enabled and at least one Object or External metric is configured.  Scaling is active as long as at least one metric value is available.",


        {
            "feature_name": "io_k8s_api_autoscaling_v2_HPAScalingRules_stabilizationWindowSeconds",
            "description": "stabilizationWindowSeconds is the number of seconds for which past recommendations should be considered while scaling up or scaling down. StabilizationWindowSeconds must be greater than or equal to zero and less than or equal to 3600 (one hour). If not set, use the default values: - For scale up: 0 (i.e. no stabilization is done). - For scale down: 300 (i.e. the stabilization window is 300 seconds long).",
            "type_data": "integer"
        },





### Descripcion con error de escritura: Aparte se extrae solo un valor pero pueden haber varios... complejo

        "minDomains": {
          "description": "MinDomains indicates a minimum number of eligible domains. When the number of eligible domains with matching topology keys is less than minDomains, Pod Topology Spread treats \"global minimum\" as 0, and then the calculation of Skew is performed. And when the number of eligible domains with matching topology keys equals or greater than minDomains, this value has no effect on scheduling. As a result, when the number of eligible domains is less than minDomains, scheduler won't schedule more than maxSkew Pods to those domains. If value is nil, the constraint behaves as if MinDomains is equal to 1. Valid values are integers greater than 0. When value is not nil, WhenUnsatisfiable must be DoNotSchedule.\n\nFor example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same labelSelector spread as 2/2/2: | zone1 | zone2 | zone3 | |  P P  |  P P  |  P P  | The number of domains is less than 5(MinDomains), so \"global minimum\" is treated as 0. In this situation, new pod with the same labelSelector cannot be scheduled, because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones, it will violate MaxSkew.",
          "format": "int32",
          "type": "integer"
        },

        "topologyKey": {
          "description": "TopologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. We consider each <key, value> as a \"bucket\", and try to put balanced number of pods into each bucket. We define a domain as a particular instance of a topology. Also, we define an eligible domain as a domain whose nodes meet the requirements of nodeAffinityPolicy and nodeTaintsPolicy. e.g. If TopologyKey is \"kubernetes.io/hostname\", each Node is a domain of that topology. And, if TopologyKey is \"topology.kubernetes.io/zone\", each zone is a domain of that topology. It's a required field.",
          "type": "string"
        },

Otra descripcion de la que se obtiene un unico valor// dejar por defecto

        {
            "feature_name": "io_k8s_api_core_v1_Service_spec_clusterIP",
            "description": "clusterIP is the IP address of the service and is usually assigned randomly. If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be blank) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are \"None\", empty string (\"\"), or a valid IP address. Setting this to \"None\" makes a \"headless service\" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies",
            "type_data": "string"
        },
        {
            "feature_name": "io_k8s_api_core_v1_Service_spec_clusterIPs",
            "description": "ClusterIPs is a list of IP addresses assigned to this service, and are usually assigned randomly.  If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be empty) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are \"None\", empty string (\"\"), or a valid IP address.  Setting this to \"None\" makes a \"headless service\" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName.  If this field is not specified, it will be initialized from the clusterIP field.  If this field is specified, clients must ensure that clusterIPs[0] and clusterIP have the same value.\n\nThis field may hold a maximum of two entries (dual-stack IPs, in either order). These IPs must correspond to the values of the ipFamilies field. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies",
            "type_data": "Boolean"
        },

        "handler": {
          "description": "handler specifies the underlying runtime and configuration that the CRI implementation will use to handle pods of this class. The possible values are specific to the node & CRI configuration.  It is assumed that all handlers are available on every node, and handlers of the same name are equivalent on every node. For example, a handler called \"runc\" might specify that the runc OCI runtime (using native Linux containers) will be used to run the containers in a pod. The Handler must be lowercase, conform to the DNS Label (RFC 1123) requirements, and is immutable.",
          "type": "string"
        },

        "allocatedResourceStatuses": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "allocatedResourceStatuses stores status of resource being resized for the given PVC. Key names follow standard Kubernetes label syntax. Valid values are either:\n\t* Un-prefixed keys:\n\t\t- storage - the capacity of the volume.\n\t* Custom resources must use implementation-defined prefixed names such as \"example.com/my-custom-resource\"\nApart from above values - keys that are unprefixed or have kubernetes.io prefix are considered reserved and hence may not be used.\n\nClaimResourceStatus can be in any of following states:\n\t- ControllerResizeInProgress:\n\t\tState set when resize controller starts resizing the volume in control-plane.\n\t- ControllerResizeFailed:\n\t\tState set when resize has failed in resize controller with a terminal error.\n\t- NodeResizePending:\n\t\tState set when resize controller has finished resizing the volume but further resizing of\n\t\tvolume is needed on the node.\n\t- NodeResizeInProgress:\n\t\tState set when kubelet starts resizing the volume.\n\t- NodeResizeFailed:\n\t\tState set when resizing has failed in kubelet with a terminal error. Transient errors don't set\n\t\tNodeResizeFailed.\nFor example: if expanding a PVC for more capacity - this field can be one of the following states:\n\t- pvc.status.allocatedResourceStatus['storage'] = \"ControllerResizeInProgress\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"ControllerResizeFailed\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizePending\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizeInProgress\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizeFailed\"\nWhen this field is not set, it means that no resize operation is in progress for the given PVC.\n\nA controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus should ignore the update for the purpose it was designed. For example - a controller that only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid resources associated with PVC.\n\nThis is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.",
          "type": "object",
          "x-kubernetes-map-type": "granular"
        },

        {
            "feature_name": "io_k8s_api_batch_v1_CronJob_spec_jobTemplate_spec_podFailurePolicy_rules_onExitCodes_operator",
            "description": "Represents the relationship between the container exit code(s) and the specified values. Containers completed with success (exit code 0) are excluded from the requirement check. Possible values are:\n\n- In: the requirement is satisfied if at least one container exit code\n  (might be multiple if there are multiple containers not restricted\n  by the 'containerName' field) is in the set of specified values.\n- NotIn: the requirement is satisfied if at least one container exit code\n  (might be multiple if there are multiple containers not restricted\n  by the 'containerName' field) is not in the set of specified values.\nAdditional values are considered to be added in the future. Clients should react to an unknown operator by assuming the requirement is not satisfied.",
            "type_data": "string"
        },
        -Possible values are:\n\n- In: the requirement is satisfied if at least one container exit code\n  (might be multiple if there are multiple containers not restricted\n  by the 'containerName' field) is in the set of specified values.
        \n- NotIn: the requirement is satisfied if at least one container exit code\n  (might be multiple if there are multiple containers not restricted\n  by the 'containerName' field) is not in the set of specified values.
        \nAdditional values are considered to be added in the future. 
        {
            "feature_name": "io_k8s_api_batch_v1_CronJob_spec_jobTemplate_spec_podFailurePolicy_rules_onExitCodes_operator",
            "description": "Represents the relationship between the container exit code(s) and the specified values. Containers completed with success (exit code 0) are excluded from the requirement check. Possible values are:\n\n- In: the requirement is satisfied if at least one container exit code\n  (might be multiple if there are multiple containers not restricted\n  by the 'containerName' field) is in the set of specified values.\n- NotIn: the requirement is satisfied if at least one container exit code\n  (might be multiple if there are multiple containers not restricted\n  by the 'containerName' field) is not in the set of specified values.\nAdditional values are considered to be added in the future. Clients should react to an unknown operator by assuming the requirement is not satisfied.",
            "type_data": "string"
        },

        {
            "feature_name": "io_k8s_api_storage_v1alpha1_VolumeAttributesClass_parameters",
            "description": "parameters hold volume attributes defined by the CSI driver. These values are opaque to the Kubernetes and are passed directly to the CSI driver. The underlying storage provider supports changing these attributes on an existing volume, however the parameters field itself is immutable. To invoke a volume update, a new VolumeAttributesClass should be created with new parameters, and the PersistentVolumeClaim should be updated to reference the new VolumeAttributesClass.\n\nThis field is required and must contain at least one key/value pair. The keys cannot be empty, and the maximum number of parameters is 512, with a cumulative max size of 256K. If the CSI driver rejects invalid parameters, the target PersistentVolumeClaim will be set to an \"Infeasible\" state in the modifyVolumeStatus field.",
            "type_data": "Boolean"
        },
        \"Infeasible\" /// tamaño maximo de 512 o 256kb en total


      "description": "DeploymentStrategy describes how to replace existing pods with new ones.",
      "properties": {
        "rollingUpdate": {
          "$ref": "#/definitions/io.k8s.api.apps.v1.RollingUpdateDeployment",
          "description": "Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate."
        },
        "type": {
          "description": "Type of deployment. Can be \"Recreate\" or \"RollingUpdate\". Default is RollingUpdate.",
          "type": "string"
        }
      },
      "type": "object"

      "Can be"

        "JSONSchemaProps"
        "x-kubernetes-list-type": {
          "description": "x-kubernetes-list-type annotates an array to further describe its topology. This extension must only be used on lists and may have 3 possible values:\n\n1) `atomic`: the list is treated as a single entity, like a scalar.\n     Atomic lists will be entirely replaced when updated. This extension\n     may be used on any type of list (struct, scalar, ...).\n2) `set`:\n     Sets are lists that must not have multiple items with the same value. Each\n     value must be a scalar, an object with x-kubernetes-map-type `atomic` or an\n     array with x-kubernetes-list-type `atomic`.\n3) `map`:\n     These lists are like maps in that their elements have a non-index key\n     used to identify them. Order is preserved upon merge. The map tag\n     must only be used on a list with elements of type object.\nDefaults to atomic for arrays.",
          "type": "string"
        },

                "listKind": {
          "description": "listKind is the serialized kind of the list for this resource. Defaults to \"`kind`List\".",
          "type": "string"
        },

                },
        "readOnly": {
          "description": "Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.",
          "type": "boolean"
        },
        "recursiveReadOnly": {
          "description": "RecursiveReadOnly specifies whether read-only mounts should be handled recursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made recursively read-only.  If this field is set to IfPossible, the mount is made recursively read-only, if it is supported by the container runtime.  If this field is set to Enabled, the mount is made recursively read-only if it is supported by the container runtime, otherwise the pod will not be started and an error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to None (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.",
          "type": "string"
        },
        "subPath": {
          "description": "Path within the volume from which the container's volume should be mounted. Defaults to \"\" (volume's root).",
          "type": "string"
        },
        "subPathExpr": {
          "description": "Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to \"\" (volume's root). SubPathExpr and SubPath are mutually exclusive.",
          "type": "string"
        }

        ### Valores de las propiedades que solo tienen 1 valor pero no se dicta si hay 2. Boolean se da por hecho que es true o false ###
                "suspend": {
          "description": "This flag tells the controller to suspend subsequent executions, it does not apply to already started executions.  Defaults to false.",
          "type": "boolean"
        },

        ### Lo mismo que antes pero con Integer... ####
    "io.k8s.api.batch.v1.CronJobSpec": {
    }

                "failedJobsHistoryLimit": {
          "description": "The number of failed finished jobs to retain. Value must be non-negative integer. Defaults to 1.",
          "format": "int32",
          "type": "integer"
        },

                "startingDeadlineSeconds": {
          "description": "Optional deadline in seconds for starting the job if it misses scheduled time for any reason.  Missed jobs executions will be counted as failed ones.",
          "format": "int64",
          "type": "integer"
        },

        se repite mucho y tambien la muletilla "Defaults to":

                "readOnly": {
          "description": "readOnly value to pass to ControllerPublishVolumeRequest. Defaults to false (read/write).",
          "type": "boolean"
        },


*** Duda sobre como agregar los valores que se obtienen de las descripciones si tienen una referencia
este ya tendria propiedades optional y las obtenidas de las descripciones serían alternative u optionals?
- Para seguir la sintaxis como optional
- Los interpreto como valores que puede tomar el feature pero...
- Quizas error de interpretacion mio porque no es del feature en general
Creo que solo ocurre en uno, es raro generar los valores y que tenga una referencia...
        
        "template": {
          "$ref": "#/definitions/io.k8s.api.core.v1.PodTemplateSpec",
          "description": "Describes the pod that will be created when executing a job. The only allowed template.spec.restartPolicy values are \"Never\" or \"OnFailure\". More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/"
        },



        "fsType": {
        "description": "fsType is filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.",
        "type": "string"
        },


          "periodSeconds": {
          "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
          "format": "int32",
          "type": "integer"
        }   ## quizas se pueda añadir una restriccion que comprenda entre 1 < X. default to 10, minimum 1



    "io.k8s.api.core.v1.DownwardAPIVolumeSource": {
      "description": "DownwardAPIVolumeSource represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.",
      "properties": {
        "defaultMode": {
          "description": "Optional: mode bits to use on created files by default. Must be a Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.",
          "format": "int32",
          "type": "integer"
        },


                },
        "port": {
          "description": "port is an optional service port at which the webhook will be contacted. `port` should be a valid port number (1-65535, inclusive). Defaults to 443 for backward compatibility.",
          "format": "int32",
          "type": "integer"
        } ##port default, restriccion...


                "successThreshold": {
          "description": "Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.",
          "format": "int32",
          "type": "integer"
        ### Para probar si hay valores por defecto
                  "failureThreshold": {
          "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.",
          "format": "int32",
          "type": "integer"
        },
        },

        "backoffLimit": {
          "description": "Specifies the number of retries before marking this job failed. Defaults to 6",
          "format": "int32",
          "type": "integer"
        }, ### Mas defaults to {Integer}


        "kind": {
          "description": "kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared",
          "type": "string"
        }, ### No hay una separacion clara de los valores, solo el espacio y dos puntos...

        "imagePullPolicy": {
          "description": "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
          "type": "string" ## por s
        },


          "x-kubernetes-validations": {
          "description": "x-kubernetes-validations describes a list of validation rules written in the CEL expression language. This field is an alpha-level. Using this field requires the feature gate `CustomResourceValidationExpressions` to be enabled.",
          "items": {
            "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.ValidationRule"
          },
          "type": "array",
          "x-kubernetes-list-map-keys": [
            "rule"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "rule",
          "x-kubernetes-patch-strategy": "merge"
        }
      },

    "io.k8s.api.admissionregistration.v1.Validation": { ### CEL-expression con muchos parametros ""
      "description": "Validation specifies the CEL expression which is used to apply the validation.",
      "properties": {
        "expression": {
          "description": "Expression represents the expression which will be evaluated by CEL. ref: https://github.com/google/cel-spec CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:\n\n- 'object' - The object from the incoming request. The value is null for DELETE requests. - 'oldObject' - The existing object. The value is null for CREATE requests. - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)). - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind. - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources. - 'variables' - Map of composited variables, from its name to its lazily evaluated value.\n  For example, a variable named 'foo' can be accessed as 'variables.foo'.\n- 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.\n  See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz\n- 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the\n  request resource.\n\nThe `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the object. No other metadata properties are accessible.\n\nOnly property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible. Accessible property names are escaped according to the following rules when accessed in the expression: - '__' escapes to '__underscores__' - '.' escapes to '__dot__' - '-' escapes to '__dash__' - '/' escapes to '__slash__' - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:\n\t  \"true\", \"false\", \"null\", \"in\", \"as\", \"break\", \"const\", \"continue\", \"else\", \"for\", \"function\", \"if\",\n\t  \"import\", \"let\", \"loop\", \"package\", \"namespace\", \"return\".\nExamples:\n  - Expression accessing a property named \"namespace\": {\"Expression\": \"object.__namespace__ > 0\"}\n  - Expression accessing a property named \"x-prop\": {\"Expression\": \"object.x__dash__prop > 0\"}\n  - Expression accessing a property named \"redact__d\": {\"Expression\": \"object.redact__underscores__d > 0\"}\n\nEquality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1]. Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:\n  - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and\n    non-intersecting elements in `Y` are appended, retaining their partial order.\n  - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values\n    are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with\n    non-intersecting keys are appended, retaining their partial order.\nRequired.",
          "type": "string"
        },
        "message": {
          "description": "Message represents the message displayed when validation fails. The message is required if the Expression contains line breaks. The message must not contain line breaks. If unset, the message is \"failed rule: {Rule}\". e.g. \"must be a URL with the host matching spec.host\" If the Expression contains line breaks. Message is required. The message must not contain line breaks. If unset, the message is \"failed Expression: {Expression}\".",
          "type": "string"
        },
        "messageExpression": {
          "description": "messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails. Since messageExpression is used as a failure message, it must evaluate to a string. If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails. If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged. messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'. Example: \"object.x must be less than max (\"+string(params.max)+\")\"",
          "type": "string"
        },
        "reason": {
          "description": "Reason represents a machine-readable description of why this validation failed. If this is the first validation in the list to fail, this reason, as well as the corresponding HTTP response code, are used in the HTTP response to the client. The currently supported reasons are: \"Unauthorized\", \"Forbidden\", \"Invalid\", \"RequestEntityTooLarge\". If not set, StatusReasonInvalid is used in the response to the client.",
          "type": "string"
        }
      },
      "required": [
        "expression"
      ],
      "type": "object"
    },
    "io.k8s.api.autoscaling.v2.HorizontalPodAutoscalerBehavior": { ### Expresiones un poco mas complejas para mapear pero posibles
      "description": "HorizontalPodAutoscalerBehavior configures the scaling behavior of the target in both Up and Down directions (scaleUp and scaleDown fields respectively).",
      "properties": {
        "scaleDown": {
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2.HPAScalingRules",
          "description": "scaleDown is scaling policy for scaling Down. If not set, the default value is to allow to scale down to minReplicas pods, with a 300 second stabilization window (i.e., the highest recommendation for the last 300sec is used)."
        },
        "scaleUp": {
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2.HPAScalingRules",
          "description": "scaleUp is scaling policy for scaling Up. If not set, the default value is the higher of:\n  * increase no more than 4 pods per 60 seconds\n  * double the number of pods per 60 seconds\nNo stabilization is used."
        }
      },
      "type": "object"
    },

      dependences: requires
      "description": "volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim. If specified, the CSI driver will create or update the volume with the attributes defined in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName, it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass will be applied to the claim but it's not allowed to reset this field to empty string once it is set. If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass will be set by the persistentvolume controller if it exists. If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource exists. More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/ (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.",

      "restartPolicy": { # valores sin palabras clave
        "description": "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
        "type": "string"
      },

      "details": { ### Espacio de mas en una descripcion 
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.StatusDetails",

      ### Valores con comillas invertidas *No las tenia en cuenta
        "parameterNotFoundAction": {
          "description": "`parameterNotFoundAction` controls the behavior of the binding when the resource exists, and name or selector is valid, but there are no parameters matched by the binding. If the value is set to `Allow`, then no matched parameters will be treated as successful validation by the binding. If set to `Deny`, then no matched parameters will be subject to the `failurePolicy` of the policy.\n\nAllowed values are `Allow` or `Deny` Default to `Deny`",
          "type": "string"
        },  ##policy.\n\nAllowed values are `Allow` or `Deny` Default to `Deny`", 

        "immutable": { ### Error en la doc ==> "nil" en vez de null
          "description": "Immutable, if set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Defaulted to nil.",
          "type": "boolean"
        },
This is an alpha field

"description": "ResourceClaim describes which resources are needed by a resource consumer. Its status tracks whether the resource has been allocated and what the resulting attributes are.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate.",

hay varias asi: si se automatiza el encontrar a donde apunta se puede poner un !require (to be false) y un require (to be set)
        "default": y mas...

---Hecho
"description": "strategy specifies how custom resources are converted between versions. Allowed values are: - `\"None\"`: The converter only change the apiVersion and would not touch any other field in the custom resource. - `\"Webhook\"`: API Server will call to an external webhook to do the conversion. Additional information\n  is needed for this option. This requires spec.preserveUnknownFields to be false, and spec.conversion.webhook to be set.",
        "webhook": {
          "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.WebhookConversion",
          "description": "webhook describes how to call the conversion webhook. Required when `strategy` is set to `\"Webhook\"`."
        }
io_k8s_api_networking_v1_IngressClassSpec_parameters_scope_Namespace => io_k8s_api_networking_v1_IngressClassList_items_spec_parameters_namespace
io_k8s_api_networking_v1_IngressClassSpec_parameters_scope_Cluster => !io_k8s_api_networking_v1_IngressClassList_items_spec_parameters_namespace
---Hecho

uvl: feature_strategy_Webhook => feature
Otra descripcion que requiere algo pero no esta en los esquemas..
"description": "lastPhaseTransitionTime is the time the phase transitioned from one to another and automatically resets to current time everytime a volume phase transitions. This is a beta field and requires the PersistentVolumeLastPhaseTransitionTime feature to be enabled (enabled by default)."

## Probando combinaciones ya 'buscadas': requires
This is an alpha field

if this is -- comprobando

The currently supported reasons are:

Valid options are

number is the numerical port number (e.g. 80)

If not set

 --5 constraint de puertos con los numeros validos **intervalos integer: ---Hecho
should be a valid port number (1-65535, inclusive)."
This must be a valid port number, 0 < x < 65536."
If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork
Otro: must be in the range [**]

"port": {  ## En estas descripciones al poder ser integer (número del puerto) o string (nombre del puerto) solo se deberia poder usar la limitacion de los rangos mediante una condicion
  "$ref": "#/definitions/io.k8s.apimachinery.pkg.util.intstr.IntOrString",
  {feature_asInteger} => feature > 1 & feature < 65535
  feature_asString => feature = 'IANA_SVC_NAME'
port name (IANA_SVC_NAME): An alphanumeric (a-z, and 0-9) string, with a maximum length of 15 characters, with the '-' character allowed anywhere except the first or the last character 
or adjacent to another '-' character, it must contain at least a (a-z) character.
  "description": "Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME."
  }
--- Hecho


The currently supported reasons are: (4 pero similares, comillas y barras laterales) --- Hecho
to the client. The currently supported reasons are: \"Unauthorized\", \"Forbidden\", \"Invalid\", \"RequestEntityTooLarge\". If not set, StatusReasonInvalid is used in the response to the client.",
--- Hecho

--- Hecho: Implementacion en el mismo metodo diseñado antes, modificacion del original (con patrones directamente), se pudo agregar las cond directamente
must be greater than, 4
. It must be greater than zero",
PeriodSeconds must be greater than zero and less than or equal to 1800 (30 min).",
down. StabilizationWindowSeconds must be greater than or equal to zero and less than or equal to 3600 (one hour). If not set, use the default values: 
- For scale up: 0 (i.e. no stabilization is done). - For scale down: 300 (i.e. the stabilization window is 300 seconds long).",
"VersionPriority controls the ordering of this API version inside of its group.  Must be greater than zero. The primary
--- Hecho

## Probando combinaciones ya 'buscadas': only if

Default value is [Integer]: Para numeros enteros (revisar) (4 - PREGUNTAR
)
p. This cannot be 0 if MaxSurge is 0 Default value is 1.

---Hecho -> only if type
Can be:
"description": "Type of daemon set update. Can be \"RollingUpdate\" or \"OnDelete\". Default is RollingUpdate.",

Posible constraint entre las 2 propiedades del tipo rollingUpdate y type ** Present only if **
"description": "Rolling update config params. Present only if type = \"RollingUpdate\"."

si el tipo es igual a Rolling update config params "rollingUpdate" esta presente sino no...

feature_type == 'RollingUpdate' => feature_rollingUpdate
feature_type == 'OnDelete' => !feature_rollingUpdate
constraint: io_k8s_api_apps_v1_DaemonSetUpdateStrategy_type_RollingUpdate => io_k8s_api_apps_v1_DaemonSetUpdateStrategy_rollingUpdate
!io_k8s_api_apps_v1_DaemonSetUpdateStrategy_type_RollingUpdate | io_k8s_api_apps_v1_DaemonSetUpdateStrategy_type_OnDelete => !io_k8s_api_apps_v1_DaemonSetUpdateStrategy_rollingUpdate
---Hecho

This list may be empty, but only if `clusterScope` is true." -- constraint (2)

-- Hecho ## añadir valores A value of `

PriorityLevelConfigurationSpec: dependencia entre propiedades, if b == "limited" => a != vacio
This field must be non-empty if and only if `type` is `\"Limited\"`."
io_k8s_api_flowcontrol_v1_PriorityLevelConfiguration_spec_type_Limited => io_k8s_api_flowcontrol_v1_PriorityLevelConfiguration_spec_limited

"description": "`limited` specifies how requests are handled for a Limited priority level. This field must be non-empty if and only if `type` is `\"Limited\"`."

 io_k8s_api_flowcontrol_v1_PriorityLevelConfiguration_spec_type_Limited => io_k8s_api_flowcontrol_v1_PriorityLevelConfiguration_spec_limited

"description": "`exempt` specifies how requests are handled for an exempt priority level. This field MUST be empty if `type` is `\"Limited\"`. This field MAY be non-empty if `type` is `\"Exempt\"`. If empty and `type` is `\"Exempt\"` then the default values for `ExemptPriorityLevelConfiguration` apply."
io_k8s_api_flowcontrol_v1_PriorityLevelConfiguration_spec_type_Limited => !io_k8s_api_flowcontrol_v1_PriorityLevelConfiguration_spec_exempt | io_k8s_api_flowcontrol_v1_PriorityLevelConfiguration_spec_type_Exempt => io_k8s_api_flowcontrol_v1_PriorityLevelConfiguration_spec_exempt 

-- Hecho

fields-to-discriminateBy: caracteristica que indica los features y nombres que "deberian" ser ***

posible constraint: if name == '' => generateName
GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided.
n\nSi se especifica este campo y el nombre generado existe, el servidor devolverá un 409.\n\nSólo se aplica si no se especifica Nombre. se tendria que comprobar si el nombre ya existe en el servidor



"description": "timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == \"ClientIP\". Default value is 10800(for 3 hours).",

Must be set if and only if type is \"Localhost\".", -- Valor por defecto(?)


"fields-to-discriminateBy" ### mirar, podria ser interesante, val x defecto

---Hecho
"description": "localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must be set if type is \"Localhost\". Must NOT be set for any other type.",
# Quitar los alternative con 1 solo valoro tratar de omitir su representacion..
io_k8s_api_apps_v1_StatefulSet_spec_template_spec_topologySpreadConstraints_topologyKey
io_k8s_api_apps_v1_StatefulSet_spec_template_spec_topologySpreadConstraints_minDomains
--- Hecho y comprobando cuales se omiten para detectar si en alguna descripcion hay mas de 1 valor
---Hecho
values:
"description": "status is the status of the ControllerModifyVolume operation. It can be in any of following states:\n - Pending\n   Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as\n   the specified VolumeAttributesClass not existing.\n - InProgress\n   InProgress indicates that the volume is being modified.\n - Infeasible\n  Infeasible indicates that the request has been rejected as invalid by the CSI driver. To\n\t  resolve the error, a valid VolumeAttributesClass needs to be specified.\nNote: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.",
io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_modifyVolumeStatus : mas de un valor
---Hecho

---Hecho \ Faltan restricciones (HECHO-- Localhost)
Valid options are: (2)
Valid options are (5)
"description": "type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. \"ClusterIP\" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is \"None\", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. \"NodePort\" builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. \"LoadBalancer\" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. \"ExternalName\" aliases this service to the specified externalName. Several other fields do not apply to ExternalName services. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types",
---Hecho

Aqui se podria añadir una regla aparte donde se describa que si hay reglas tipo Ingress o Egress se define el policyTypes tambien. -- SIN TERMINAR ESTA PARTE
[\"Ingress\"], [\"Egress\"], or [\"Ingress\", \"Egress\"]. => Si no es especificada, depende del contenido en sus propiedades. or [0..2], con complejidad de relacion

"description": "policyTypes is a list of rule types that the NetworkPolicy relates to. Valid options are [\"Ingress\"], [\"Egress\"], or [\"Ingress\", \"Egress\"]. If this field is not specified, it will default based on the existence of ingress or egress rules; policies that contain an egress section are assumed to affect egress, and all policies (whether or not they contain an ingress section) are assumed to affect ingress. If you want to write an egress-only policy, you must explicitly specify policyTypes [ \"Egress\" ]. Likewise, if you want to write a policy that specifies that no egress is allowed, you must specify a policyTypes value that include \"Egress\" (since such a policy would not include an egress section and would otherwise default to just [ \"Ingress\" ]). This field is beta-level in 1.8",
        
        "persistentVolumeReclaimPolicy": { ## Este quizas saltarlo por la posible obtencion de valores no deseados. Patron con palabra y comas...
          "description": "persistentVolumeReclaimPolicy defines what happens to a persistent volume when released from its claim. Valid options are Retain (default for manually created PersistentVolumes), Delete (default for dynamically provisioned PersistentVolumes), and Recycle (deprecated). Recycle must be supported by the volume plugin underlying this PersistentVolume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming",
          "type": "string"
        },

        },
        "type": { ### Se referencian las 4 "posibles opciones" pero se menciona que Si clusterIP es "None"
          "description": "type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. \"ClusterIP\" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is \"None\", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. \"NodePort\" builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. \"LoadBalancer\" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. \"ExternalName\" aliases this service to the specified externalName. Several other fields do not apply to ExternalName services. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types",
          "type": "string"
        }
---Hecho


--Nuevo--
Valid values are either: Da problemas porque captura un valor no deseado pero tiene otro que puede ser un valor pero String.. Es decir, hay uno definido por defecto y otro libre a usar por el usuario...
Interviene en la expresion que captura los valores de valid options are...

--Nuevo--

--- Hecho
Supports:: añadido
---Hecho

## Revisar la coincidencia entre la descripcion principal y el enum, Revisado y no hay tantas coincidencias como pensaba...
    "io.k8s.api.apps.v1.StatefulSet": { 
      "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n  - Network: A single stable DNS and hostname.\n  - Storage: As many VolumeClaims as requested.\n\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity.",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": [
            "StatefulSet"
          ]
        },

varios valores que no deberian de estar en este feature y otros...
Revisar expresion, enfoque... (patrones en un mismo lugar...): prefixed_keys, example, capacity, values de más. 

											Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResourceStatuses
												alternative
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResourceStatuses_NodeResizePending
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResourceStatuses_NodeResizeFailed
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResourceStatuses_prefixed_keys
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResourceStatuses_NodeResizeInProgress
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResourceStatuses_capacity
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResourceStatuses_storage
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResourceStatuses_example
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResourceStatuses_ControllerResizeFailed
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResourceStatuses_values
											Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResources
												alternative
													String io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResources_asString
													Integer io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResources_asNumber
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResources_prefixed_keys
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResources_example
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResources_values
													Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_allocatedResources_storage
											Boolean io_k8s_api_apps_v1_StatefulSet_spec_volumeClaimTemplates_status_capacity

Nueva xpresion que puede significar mandatory: \n\nRequired"

"description": "`parameterNotFoundAction` controls the behavior of the binding when the resource exists, and name or selector is valid, but there are no parameters matched by the binding. If the value is set to `Allow`, then no matched parameters will be treated as successful validation by the binding. If set to `Deny`, then no matched parameters will be subject to the `failurePolicy` of the policy.\n\nAllowed values are `Allow` or `Deny`\n\nRequired",


Quizas sirva para abrir 2 restricciones beta
and requires the

--- Hecho
          "description": "name is the name of the resource being referenced.\n\nOne of `name` or `selector` must be set, but `name` and `selector` are mutually exclusive properties. If one is set, the other must be unset.\n\nA single parameter used for all admission requests can be configured by setting the `name` field, leaving `selector` blank, and setting namespace if `paramKind` is namespace-scoped.",
restriccions exclusivas con require:
if (feature_name => !feature_selector) & (feature_selector => !feature_name)
--- Hecho

          "description": "namespace is the namespace of the referenced resource. Allows limiting the search for params to a specific namespace. Applies to both `name` and `selector` fields.\n\nA per-namespace parameter may be used by specifying a namespace-scoped `paramKind` in the policy and leaving this field empty.\n\n- If `paramKind` is cluster-scoped, this field MUST be unset. Setting this field results in a configuration error.\n\n- If `paramKind` is namespace-scoped, the namespace of the object being evaluated for admission will be used when this field is left unset. Take care that if this is left empty the binding must not match any cluster-scoped resources, which will result in an error.",

\n\n- If `paramKind` is cluster-scoped, this field MUST be unset. 

Expresion "One of" con mayus


+ Valores:
"description": "`type` is the type of flow distinguisher method The supported types are \"ByUser\" and \"ByNamespace\". Required.",
The supported types are (2 tipos) : 16 insertados

-- Hacer: Insertar como default los enteros que tambien tienen {default} 
-- Hacer: actualizacion formato de añadir los Boolean


Descripciones para Rangos Integer y valor por defecto
ClientIPConfig
Default value is 0.
This cannot be 0 if MaxSurge is 0 Default value is 1.
The default value is 10.
"description": "timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == \"ClientIP\". Default value is 10800(for 3 hours).",

terminationGracePeriodSeconds:  ## Complicado para implementar, posibles opciones etc..
Minimum value is 1  rule > 1
Minimum value is (5) para constraints

Defaults to 1
Defaults to 3
Defaults to 6
Defaults to 600


"description": "appArmorProfile is the AppArmor options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows."

"io.k8s.api.core.v1.AppArmorProfile": {

The profile must be preconfigured on the node to work. Must match the loaded name of the profile.
this field cannot be set when 

spec.os.name
se podria traducir a "io_k8s_api_core_v1_PodSpec_os"
esquema: PodOS => agregar linunx and windows
"description": "Name is the name of the operating system. The currently supported values are linux and windows. Additional value may be defined in future and can be one of: https://github.com/opencontainers/runtime-spec/blob/master/config.md#platform-specific-configuration Clients should expect to handle additional values and treat unrecognized values in this field as os: null",
ref a "os"
"$ref": "#/definitions/io.k8s.api.core.v1.PodOS",
"description": "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup"

feature al que apuntaran los spec.os.name: PodSpec.os
"description": "AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.",
Constraints::
io_k8s_api_core_v1_PodSpec_os_name
io_k8s_api_core_v1_PodSpec_os_name_windows => !io_k8s_api_apps_v1_DaemonSet_spec_template_spec_containers_securityContext_allowPrivilegeEscalation


"description": "The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.",
io_k8s_api_core_v1_PodSpec_os_name_linux => !io_k8s_api_apps_v1_DaemonSet_spec_template_spec_containers_securityContext_windowsOptions
                                             io_k8s_api_apps_v1_DaemonSet_spec_template_spec_os_name_linux
Parte del nombre a coger:: io_k8s_api_apps_v1_DaemonSet_spec_template_spec
Total 1247 features
_spec_template_spec_ 688 features
_template_spec_ (1032) features -- Haciendo


215 pendientes
io_k8s_api_core_v1_Container_securityContext_allowPrivilegeEscalation => no encuentro spec, por defecto esquema general spec_os_name? 
io_k8s_api_core_v1_EphemeralContainer_securityContext_runAsGroup =>igual

io_k8s_api_core_v1_Pod_spec_containers_securityContext_allowPrivilegeEscalation => io_k8s_api_core_v1_Pod_spec_os 
_Pod_spec_ (43 features) --
¿Cada spec.os.name se refiere al esquema general o al propio a cada esquema?
172 restantes
io_k8s_api_core_v1_PodList_items_spec_containers_securityContext_allowPrivilegeEscalation => io_k8s_api_core_v1_PodList_items_spec_os_name 
_PodList_items_spec_ (43) -- Haciendo / Falta parte String, Integer
129 restantes
io_k8s_api_core_v1_PodSpec_containers_securityContext_allowPrivilegeEscalation => io_k8s_api_core_v1_PodSpec_os_name
_core_v1_PodSpec_ (43) -- Haciendo
86 restantes
io_k8s_api_core_v1_PodTemplateSpec_spec_containers_securityContext_allowPrivilegeEscalation => 
_PodTemplateSpec_spec_ (43) -- Haciendo
43 restantes
io_k8s_api_core_v1_Container_securityContext_allowPrivilegeEscalation
_v1_Container_securityContext_ (11)
io_k8s_api_core_v1_EphemeralContainer_securityContext_allowPrivilegeEscalation
_v1_EphemeralContainer_securityContext_ (11)
_PodSecurityContext_ (10) sin spec_os_name
io_k8s_api_core_v1_SecurityContext_allowPrivilegeEscalation => 
_v1_SecurityContext_ _(11) -- Haciendo

0 restantes
Deducciones:
\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups
if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions

    "io.k8s.api.core.v1.SecurityContext": {
      "description": "SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence.",
      "properties": {
        "allowPrivilegeEscalation": {
          "description": "AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.",
          "type": "boolean"
        },
        "appArmorProfile": {
          "$ref": "#/definitions/io.k8s.api.core.v1.AppArmorProfile",
          "description": "appArmorProfile is the AppArmor options to use by this container. If set, this profile overrides the pod's appArmorProfile. Note that this field cannot be set when spec.os.name is windows."
        },
        "capabilities": {
          "$ref": "#/definitions/io.k8s.api.core.v1.Capabilities",
          "description": "The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows."
        },
        "privileged": {
          "description": "Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.",
          "type": "boolean"
        },
        "procMount": {
          "description": "procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.",
          "type": "string"
        },
        "readOnlyRootFilesystem": {
          "description": "Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.",
          "type": "boolean"
        },
        "runAsGroup": {
          "description": "The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.",